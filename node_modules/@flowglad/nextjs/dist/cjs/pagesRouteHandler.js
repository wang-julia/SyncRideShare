"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var pagesRouteHandler_exports = {};
__export(pagesRouteHandler_exports, {
  pagesRouteHandler: () => pagesRouteHandler
});
module.exports = __toCommonJS(pagesRouteHandler_exports);
var import_server = require("@flowglad/server");
const normalizeQueryParameters = (query) => {
  return Object.fromEntries(
    Object.entries(query).map(([key, value]) => [
      key,
      Array.isArray(value) ? value[0] : value
    ]).filter(
      (entry) => entry[1] !== void 0
    )
  );
};
const pagesRouteHandler = (options) => {
  const _a = options, { beforeRequest, afterRequest } = _a, requestHandlerOptions = __objRest(_a, ["beforeRequest", "afterRequest"]);
  const handler = (0, import_server.requestHandler)(
    requestHandlerOptions
  );
  return (req, res) => __async(null, null, function* () {
    var _a2;
    const path = req.query.path;
    const method = req.method;
    const query = req.method === "GET" ? normalizeQueryParameters(req.query) : void 0;
    const body = req.method !== "GET" ? req.body : void 0;
    let result = null;
    try {
      if (beforeRequest) {
        yield beforeRequest(req, { path, method, query, body });
      }
      result = yield handler(
        {
          path,
          method,
          query,
          body
        },
        req
      );
      res.status(result.status).json({
        error: result.error,
        data: result.data
      });
    } catch (error) {
      (_a2 = options.onError) == null ? void 0 : _a2.call(options, error);
      const errorResult = {
        status: 500,
        error: {
          message: error instanceof Error ? error.message : "Internal server error"
        },
        data: null
      };
      res.status(errorResult.status).json({
        error: errorResult.error,
        data: errorResult.data
      });
      result = errorResult;
    } finally {
      if (afterRequest && result) {
        yield afterRequest(req, result);
      }
    }
  });
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  pagesRouteHandler
});
//# sourceMappingURL=pagesRouteHandler.js.map