import {
  __async,
  __spreadProps,
  __spreadValues
} from "../chunk-E3LOUS7X.mjs";
import {
  FlowgladActionKey,
  flowgladActionValidators,
  HTTPMethod
} from "@flowglad/shared";
import { getSessionFromCtx } from "better-auth/api";
import { createAuthEndpoint } from "better-auth/plugins";
import { z } from "zod";
import { FlowgladServer } from "../FlowgladServer.mjs";
import { FlowgladServerAdmin } from "../FlowgladServerAdmin.mjs";
import { routeToHandlerMap } from "../subrouteHandlers/index.mjs";
import { getPricingModel } from "../subrouteHandlers/pricingModelHandlers.mjs";
const isRecord = (value) => {
  return typeof value === "object" && value !== null && !Array.isArray(value);
};
const getStringProp = (record, key) => {
  const value = record[key];
  if (typeof value !== "string") {
    return null;
  }
  return value;
};
const isAdapterLike = (value) => {
  if (!isRecord(value)) {
    return false;
  }
  return typeof value.findOne === "function" && typeof value.findMany === "function";
};
const getOrgOptionsFromCtxContext = (ctxContext) => {
  if (!isRecord(ctxContext)) {
    return void 0;
  }
  const orgOptions = ctxContext.orgOptions;
  if (!isRecord(orgOptions)) {
    return void 0;
  }
  return orgOptions;
};
const getCreatorRoleFromOrgOptions = (orgOptions) => {
  if (!orgOptions) {
    return void 0;
  }
  const creatorRole = orgOptions.creatorRole;
  return typeof creatorRole === "string" ? creatorRole : void 0;
};
const getOrganizationDetails = (params) => __async(null, null, function* () {
  var _a, _b, _c, _d, _e, _f;
  const creatorRole = (_a = params.creatorRole) != null ? _a : "owner";
  const [memberResult, organizationResult, ownerMembersResult] = yield Promise.all([
    params.adapter.findOne({
      model: "member",
      where: [
        { field: "userId", value: params.userId },
        { field: "organizationId", value: params.organizationId }
      ]
    }),
    params.adapter.findOne({
      model: "organization",
      where: [{ field: "id", value: params.organizationId }]
    }),
    params.adapter.findMany({
      model: "member",
      where: [
        { field: "organizationId", value: params.organizationId },
        { field: "role", value: creatorRole }
      ]
    })
  ]);
  if (!isRecord(memberResult)) {
    return null;
  }
  const memberRole = getStringProp(memberResult, "role");
  const memberUserId = (_b = getStringProp(memberResult, "userId")) != null ? _b : params.userId;
  let ownerUserId = memberRole === creatorRole ? memberUserId : null;
  if (!ownerUserId && Array.isArray(ownerMembersResult)) {
    const firstOwner = (_c = ownerMembersResult.find(isRecord)) != null ? _c : null;
    ownerUserId = firstOwner ? getStringProp(firstOwner, "userId") : null;
  }
  const ownerUserResult = ownerUserId ? yield params.adapter.findOne({
    model: "user",
    where: [{ field: "id", value: ownerUserId }]
  }) : null;
  const organizationName = isRecord(organizationResult) ? (_e = (_d = getStringProp(organizationResult, "name")) != null ? _d : getStringProp(organizationResult, "slug")) != null ? _e : "Organization" : "Organization";
  const ownerEmail = isRecord(ownerUserResult) ? (_f = getStringProp(ownerUserResult, "email")) != null ? _f : "" : "";
  return {
    id: params.organizationId,
    name: organizationName,
    email: ownerEmail
  };
});
const createGetCustomerDetails = (params) => {
  return () => __async(null, null, function* () {
    var _a;
    const organizationId = params.options.customerType === "organization" ? (_a = params.session.session.activeOrganizationId) != null ? _a : null : null;
    const innerSession = {
      user: {
        id: params.session.user.id,
        name: params.session.user.name || "",
        email: params.session.user.email || "",
        organizationId
      }
    };
    if (params.options.getCustomer) {
      const customerInfo = yield params.options.getCustomer(innerSession);
      return { name: customerInfo.name, email: customerInfo.email };
    }
    if (params.options.customerType === "organization" && params.session.session.activeOrganizationId && isAdapterLike(params.adapter)) {
      const creatorRole = getCreatorRoleFromOrgOptions(
        getOrgOptionsFromCtxContext(params.ctxContext)
      );
      const org = yield getOrganizationDetails({
        adapter: params.adapter,
        organizationId: params.session.session.activeOrganizationId,
        userId: params.session.user.id,
        creatorRole
      });
      if (org) {
        return { name: org.name, email: org.email };
      }
    }
    return {
      name: params.session.user.name || "",
      email: params.session.user.email || ""
    };
  });
};
const resolveCustomerExternalId = (options, session) => {
  if (options.customerType === "organization") {
    if (!session.session.activeOrganizationId) {
      return {
        error: {
          code: "NO_ACTIVE_ORGANIZATION",
          message: "Organization billing requires an active organization. Please select or create an organization first."
        }
      };
    }
    return { externalId: session.session.activeOrganizationId };
  }
  return { externalId: session.session.userId };
};
const createGetExternalIdEndpoint = (options) => {
  return createAuthEndpoint(
    "/flowglad/get-external-id",
    {
      method: "GET",
      metadata: {
        isAction: true
      }
    },
    (ctx) => __async(null, null, function* () {
      if (!ctx.headers || !ctx.headers.get) {
        throw new Error(
          "Flowglad Better Auth Plugin: Headers are required for getExternalId().\nUsage: await auth.api.getExternalId({ headers: await headers() })"
        );
      }
      const session = yield getSessionFromCtx(ctx);
      if (!session) {
        return ctx.json({
          externalId: null
        });
      }
      const organizationId = session.session.activeOrganizationId;
      if (options.customerType === "organization") {
        return ctx.json({
          externalId: organizationId != null ? organizationId : null
        });
      }
      return ctx.json({
        externalId: session.session.userId
      });
    })
  );
};
const createFlowgladBillingEndpoint = (params) => {
  return createAuthEndpoint(
    `/flowglad/${params.actionKey}`,
    {
      method: "POST",
      // Use a permissive schema so Better Call parses the JSON body for us
      // Handlers will do their own validation
      body: z.record(z.string(), z.any()),
      metadata: {
        isAction: true
      }
    },
    (ctx) => __async(null, null, function* () {
      var _a;
      const sessionResult = yield getSessionFromCtx(ctx);
      if (!sessionResult) {
        return ctx.json(
          {
            error: {
              code: "UNAUTHORIZED",
              message: "Authentication required"
            }
          },
          { status: 401 }
        );
      }
      const session = sessionResult;
      const getCustomerDetailsForSession = createGetCustomerDetails({
        options: params.options,
        session,
        ctxContext: ctx.context,
        adapter: ctx.context.adapter
      });
      const customerResult = resolveCustomerExternalId(
        params.options,
        session
      );
      if ("error" in customerResult) {
        return ctx.json(
          { error: customerResult.error },
          { status: 400 }
        );
      }
      if (params.options.customerType === "organization" && isAdapterLike(ctx.context.adapter)) {
        const membership = yield ctx.context.adapter.findOne({
          model: "member",
          where: [
            { field: "userId", value: session.user.id },
            {
              field: "organizationId",
              value: customerResult.externalId
            }
          ]
        });
        if (!isRecord(membership)) {
          return ctx.json(
            {
              error: {
                code: "NOT_ORGANIZATION_MEMBER",
                message: "You are not a member of this organization"
              }
            },
            { status: 403 }
          );
        }
      }
      const rawBody = isRecord(ctx.body) ? ctx.body : {};
      const shouldInjectCustomerExternalIdIntoBody = params.actionKey === FlowgladActionKey.GetCustomerBilling || params.actionKey === FlowgladActionKey.FindOrCreateCustomer || params.actionKey === FlowgladActionKey.UpdateCustomer;
      const bodyForValidation = shouldInjectCustomerExternalIdIntoBody ? __spreadProps(__spreadValues({}, rawBody), {
        externalId: customerResult.externalId
      }) : rawBody;
      const validatedBody = params.validator.inputValidator.safeParse(bodyForValidation);
      if (!validatedBody.success) {
        return ctx.json(
          {
            error: {
              code: "VALIDATION_ERROR",
              message: "Invalid request body",
              details: validatedBody.error.flatten()
            }
          },
          { status: 400 }
        );
      }
      const apiKey = params.options.apiKey || process.env.FLOWGLAD_SECRET_KEY;
      const flowgladServerConfig = {
        customerExternalId: customerResult.externalId,
        getCustomerDetails: getCustomerDetailsForSession
      };
      if (apiKey) {
        flowgladServerConfig.apiKey = apiKey;
      }
      if (params.options.baseURL) {
        flowgladServerConfig.baseURL = params.options.baseURL;
      }
      const flowgladServer = new FlowgladServer(flowgladServerConfig);
      const result = yield params.handler(
        {
          method: params.validator.method,
          data: validatedBody.data
        },
        flowgladServer
      );
      if (result.error) {
        return ctx.json(
          {
            error: {
              code: result.error.code,
              message: typeof ((_a = result.error.json) == null ? void 0 : _a.message) === "string" ? result.error.json.message : `Flowglad API error: ${result.error.code}`,
              details: result.error.json
            }
          },
          { status: result.status }
        );
      }
      return ctx.json(
        { data: result.data },
        { status: result.status }
      );
    })
  );
};
const createGetPricingModelEndpoint = (options) => {
  return createAuthEndpoint(
    "/flowglad/pricing-models/retrieve",
    {
      method: "POST",
      metadata: {
        isAction: true
      }
    },
    (ctx) => __async(null, null, function* () {
      const apiKey = options.apiKey || process.env.FLOWGLAD_SECRET_KEY;
      if (!apiKey) {
        return ctx.json(
          {
            error: {
              code: "CONFIGURATION_ERROR",
              message: "API key required. Provide apiKey option or set FLOWGLAD_SECRET_KEY."
            }
          },
          { status: 500 }
        );
      }
      const flowgladServerAdmin = new FlowgladServerAdmin({
        apiKey,
        baseURL: options.baseURL
      });
      let flowgladServer = null;
      const sessionResult = yield getSessionFromCtx(ctx);
      if (sessionResult) {
        const session = sessionResult;
        const customerResult = resolveCustomerExternalId(
          options,
          session
        );
        if (!("error" in customerResult)) {
          const getCustomerDetailsForSession = createGetCustomerDetails({
            options,
            session,
            ctxContext: ctx.context,
            adapter: ctx.context.adapter
          });
          const flowgladServerConfig = {
            customerExternalId: customerResult.externalId,
            getCustomerDetails: getCustomerDetailsForSession
          };
          if (apiKey) {
            flowgladServerConfig.apiKey = apiKey;
          }
          if (options.baseURL) {
            flowgladServerConfig.baseURL = options.baseURL;
          }
          flowgladServer = new FlowgladServer(flowgladServerConfig);
        }
      }
      const result = yield getPricingModel(
        { method: HTTPMethod.POST, data: {} },
        { flowgladServer, flowgladServerAdmin }
      );
      if (result.error) {
        const errorJson = result.error.json;
        const message = typeof (errorJson == null ? void 0 : errorJson.message) === "string" ? errorJson.message : void 0;
        const details = typeof (errorJson == null ? void 0 : errorJson.details) === "string" ? errorJson.details : void 0;
        return ctx.json(
          {
            error: {
              code: result.error.code,
              message,
              details
            }
          },
          { status: result.status }
        );
      }
      return ctx.json({ data: result.data });
    })
  );
};
const createBillingEndpoints = (options) => {
  return {
    getCustomerBilling: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.GetCustomerBilling,
      validator: flowgladActionValidators[FlowgladActionKey.GetCustomerBilling],
      handler: routeToHandlerMap[FlowgladActionKey.GetCustomerBilling],
      options
    }),
    findOrCreateCustomer: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.FindOrCreateCustomer,
      validator: flowgladActionValidators[FlowgladActionKey.FindOrCreateCustomer],
      handler: routeToHandlerMap[FlowgladActionKey.FindOrCreateCustomer],
      options
    }),
    createCheckoutSession: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.CreateCheckoutSession,
      validator: flowgladActionValidators[FlowgladActionKey.CreateCheckoutSession],
      handler: routeToHandlerMap[FlowgladActionKey.CreateCheckoutSession],
      options
    }),
    createAddPaymentMethodCheckoutSession: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.CreateAddPaymentMethodCheckoutSession,
      validator: flowgladActionValidators[FlowgladActionKey.CreateAddPaymentMethodCheckoutSession],
      handler: routeToHandlerMap[FlowgladActionKey.CreateAddPaymentMethodCheckoutSession],
      options
    }),
    createActivateSubscriptionCheckoutSession: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.CreateActivateSubscriptionCheckoutSession,
      validator: flowgladActionValidators[FlowgladActionKey.CreateActivateSubscriptionCheckoutSession],
      handler: routeToHandlerMap[FlowgladActionKey.CreateActivateSubscriptionCheckoutSession],
      options
    }),
    cancelSubscription: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.CancelSubscription,
      validator: flowgladActionValidators[FlowgladActionKey.CancelSubscription],
      handler: routeToHandlerMap[FlowgladActionKey.CancelSubscription],
      options
    }),
    uncancelSubscription: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.UncancelSubscription,
      validator: flowgladActionValidators[FlowgladActionKey.UncancelSubscription],
      handler: routeToHandlerMap[FlowgladActionKey.UncancelSubscription],
      options
    }),
    adjustSubscription: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.AdjustSubscription,
      validator: flowgladActionValidators[FlowgladActionKey.AdjustSubscription],
      handler: routeToHandlerMap[FlowgladActionKey.AdjustSubscription],
      options
    }),
    createSubscription: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.CreateSubscription,
      validator: flowgladActionValidators[FlowgladActionKey.CreateSubscription],
      handler: routeToHandlerMap[FlowgladActionKey.CreateSubscription],
      options
    }),
    updateCustomer: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.UpdateCustomer,
      validator: flowgladActionValidators[FlowgladActionKey.UpdateCustomer],
      handler: routeToHandlerMap[FlowgladActionKey.UpdateCustomer],
      options
    }),
    createUsageEvent: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.CreateUsageEvent,
      validator: flowgladActionValidators[FlowgladActionKey.CreateUsageEvent],
      handler: routeToHandlerMap[FlowgladActionKey.CreateUsageEvent],
      options
    }),
    // Resource claim endpoints
    getResources: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.GetResourceUsages,
      validator: flowgladActionValidators[FlowgladActionKey.GetResourceUsages],
      handler: routeToHandlerMap[FlowgladActionKey.GetResourceUsages],
      options
    }),
    getResourceUsage: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.GetResourceUsage,
      validator: flowgladActionValidators[FlowgladActionKey.GetResourceUsage],
      handler: routeToHandlerMap[FlowgladActionKey.GetResourceUsage],
      options
    }),
    claimResource: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.ClaimResource,
      validator: flowgladActionValidators[FlowgladActionKey.ClaimResource],
      handler: routeToHandlerMap[FlowgladActionKey.ClaimResource],
      options
    }),
    releaseResource: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.ReleaseResource,
      validator: flowgladActionValidators[FlowgladActionKey.ReleaseResource],
      handler: routeToHandlerMap[FlowgladActionKey.ReleaseResource],
      options
    }),
    listResourceClaims: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.ListResourceClaims,
      validator: flowgladActionValidators[FlowgladActionKey.ListResourceClaims],
      handler: routeToHandlerMap[FlowgladActionKey.ListResourceClaims],
      options
    }),
    // Usage meter endpoints
    getUsageMeterBalances: createFlowgladBillingEndpoint({
      actionKey: FlowgladActionKey.GetUsageMeterBalances,
      validator: flowgladActionValidators[FlowgladActionKey.GetUsageMeterBalances],
      handler: routeToHandlerMap[FlowgladActionKey.GetUsageMeterBalances],
      options
    })
  };
};
export {
  createBillingEndpoints,
  createGetCustomerDetails,
  createGetExternalIdEndpoint,
  createGetPricingModelEndpoint,
  getCreatorRoleFromOrgOptions,
  getOrgOptionsFromCtxContext,
  getOrganizationDetails,
  getStringProp,
  isAdapterLike,
  isRecord,
  resolveCustomerExternalId
};
//# sourceMappingURL=endpoints.mjs.map