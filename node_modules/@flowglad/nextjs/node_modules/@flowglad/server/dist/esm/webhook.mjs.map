{"version":3,"sources":["../../src/webhook.ts"],"sourcesContent":["import crypto from 'crypto'\n\n/**\n * Default timestamp tolerance in seconds (5 minutes).\n * Webhooks older than this will be rejected.\n */\nconst DEFAULT_TIMESTAMP_TOLERANCE_SECONDS = 300\n\n/**\n * Maximum allowed future timestamp offset in seconds (60 seconds).\n * Webhooks with timestamps further in the future will be rejected to prevent clock skew attacks.\n */\nconst MAX_FUTURE_TIMESTAMP_OFFSET_SECONDS = 60\n\n/**\n * Error thrown when webhook verification fails.\n */\nexport class WebhookVerificationError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'WebhookVerificationError'\n  }\n}\n\n/**\n * Extract a header value from headers object, handling case-insensitive lookup\n * and array values (takes first element if array).\n *\n * @param headers - Request headers object\n * @param name - Header name (case-insensitive)\n * @returns Header value as string, or throws WebhookVerificationError if missing\n */\nfunction getHeader(\n  headers: Record<string, string | string[] | undefined>,\n  name: string\n): string {\n  const lowerName = name.toLowerCase()\n  const value = Object.entries(headers).find(\n    ([key]) => key.toLowerCase() === lowerName\n  )?.[1]\n\n  if (!value) {\n    throw new WebhookVerificationError(\n      `Missing required header: ${name}`\n    )\n  }\n\n  // Handle array values (take first element)\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      throw new WebhookVerificationError(\n        `Missing required header: ${name}`\n      )\n    }\n    return value[0]\n  }\n\n  return value\n}\n\n/**\n * Verify a webhook payload and headers.\n *\n * @param payload - The raw request body as a string or Buffer.\n *                  CRITICAL: Must be the raw, unparsed body.\n * @param headers - The request headers object. The function will extract\n *                  svix-id, svix-timestamp, and svix-signature automatically.\n * @param secret - The webhook signing secret (format: whsec_<base64-key>)\n * @param timestampToleranceSeconds - Maximum age of webhook in seconds before it's considered invalid.\n *                                    - If not provided (undefined): Uses default of 300 seconds (5 minutes)\n *                                    - If a number is provided: Uses that value in seconds\n *                                    - If null is provided: Disables timestamp validation entirely\n * @returns The verified and parsed payload (JSON object). Returns `unknown` type\n *          - caller should validate/type the result based on expected webhook event type\n * @throws WebhookVerificationError if verification fails\n */\nexport function verifyWebhook(\n  payload: string | Buffer,\n  headers: Record<string, string | string[] | undefined>,\n  secret: string,\n  timestampToleranceSeconds?: number | null\n): unknown {\n  // Extract required headers\n  const id = getHeader(headers, 'svix-id')\n  const timestamp = getHeader(headers, 'svix-timestamp')\n  const signatureHeader = getHeader(headers, 'svix-signature')\n\n  // Validate timestamp if not explicitly disabled\n  if (timestampToleranceSeconds !== null) {\n    const webhookTime = parseInt(timestamp, 10)\n    if (isNaN(webhookTime)) {\n      throw new WebhookVerificationError(\n        `Invalid timestamp format. Expected numeric timestamp, got: ${timestamp}`\n      )\n    }\n\n    const currentTime = Math.floor(Date.now() / 1000)\n    const age = currentTime - webhookTime\n\n    // Use default if not specified\n    const toleranceSeconds =\n      timestampToleranceSeconds ?? DEFAULT_TIMESTAMP_TOLERANCE_SECONDS\n\n    if (age > toleranceSeconds) {\n      throw new WebhookVerificationError(\n        `Webhook timestamp is too old. Age: ${age}s, tolerance: ${toleranceSeconds}s`\n      )\n    }\n\n    // Reject if timestamp is too far in future (clock skew protection)\n    const futureOffset = webhookTime - currentTime\n    if (\n      webhookTime >\n      currentTime + MAX_FUTURE_TIMESTAMP_OFFSET_SECONDS\n    ) {\n      throw new WebhookVerificationError(\n        `Webhook timestamp is too far in the future. Offset: ${futureOffset}s, max allowed: ${MAX_FUTURE_TIMESTAMP_OFFSET_SECONDS}s. Possible clock skew.`\n      )\n    }\n  }\n\n  // Validate secret format\n  if (!secret.startsWith('whsec_')) {\n    throw new WebhookVerificationError(\n      'Invalid secret format. Must start with whsec_'\n    )\n  }\n\n  // Extract secret key (strip whsec_ prefix and base64 decode)\n  let secretKey: Buffer\n  try {\n    const secretBase64 = secret.split('_')[1]\n    if (!secretBase64) {\n      throw new WebhookVerificationError(\n        'Invalid secret format. Secret must include base64-encoded key after whsec_ prefix'\n      )\n    }\n\n    // Validate base64 format (only contains valid base64 characters)\n    if (!/^[A-Za-z0-9+/]*={0,2}$/.test(secretBase64)) {\n      throw new WebhookVerificationError(\n        'Invalid secret format. Secret must be base64 encoded'\n      )\n    }\n\n    secretKey = Buffer.from(secretBase64, 'base64')\n\n    // Verify that the base64 was valid by checking if re-encoding matches\n    // (Buffer.from with 'base64' doesn't throw for invalid base64, so we need to validate)\n    if (secretKey.toString('base64') !== secretBase64) {\n      throw new WebhookVerificationError(\n        'Invalid secret format. Secret must be base64 encoded'\n      )\n    }\n  } catch (error) {\n    if (error instanceof WebhookVerificationError) {\n      throw error\n    }\n    throw new WebhookVerificationError(\n      'Invalid secret format. Secret must be base64 encoded'\n    )\n  }\n\n  // Convert payload to string if Buffer\n  const payloadString =\n    typeof payload === 'string' ? payload : payload.toString('utf8')\n\n  // Construct signed content: id.timestamp.body\n  const signedContent = `${id}.${timestamp}.${payloadString}`\n\n  // Compute expected signature\n  const expected = crypto\n    .createHmac('sha256', secretKey)\n    .update(signedContent)\n    .digest('base64')\n\n  // Handle multiple signatures (space-delimited, e.g., \"v1,sig1 v1,sig2\")\n  // Accept if ANY signature matches (supports secret rotation)\n  const signatures = signatureHeader.trim().split(/\\s+/)\n  let isValid = false\n\n  for (const signature of signatures) {\n    // Extract version and signature from \"v1,<base64-sig>\" format\n    const [version, sig] = signature.split(',')\n    if (version !== 'v1' || !sig) {\n      continue // Skip invalid format, try next signature\n    }\n\n    try {\n      const sigBuffer = Buffer.from(sig, 'base64')\n      const expectedBuffer = Buffer.from(expected, 'base64')\n\n      // Use timing-safe comparison\n      if (\n        sigBuffer.length === expectedBuffer.length &&\n        crypto.timingSafeEqual(sigBuffer, expectedBuffer)\n      ) {\n        isValid = true\n        break\n      }\n    } catch (error) {}\n  }\n\n  if (!isValid) {\n    const signatureCount = signatures.length\n    throw new WebhookVerificationError(\n      `Invalid signature. None of the ${signatureCount} provided signature${signatureCount === 1 ? '' : 's'} matched the expected signature`\n    )\n  }\n\n  // Parse and return payload\n  try {\n    return JSON.parse(payloadString)\n  } catch (error) {\n    const errorMessage =\n      error instanceof Error ? error.message : 'Unknown parsing error'\n    throw new WebhookVerificationError(\n      `Invalid JSON payload. Failed to parse: ${errorMessage}`\n    )\n  }\n}\n"],"mappings":"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","names":[]}