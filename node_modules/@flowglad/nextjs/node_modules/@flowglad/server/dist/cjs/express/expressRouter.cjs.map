{"version":3,"sources":["../../../src/express/expressRouter.ts"],"sourcesContent":["import type { HTTPMethod } from '@flowglad/shared'\nimport { type Request, type RequestHandler, Router } from 'express'\nimport {\n  type RequestHandlerOptions,\n  requestHandler,\n} from '../requestHandler'\n\n/**\n * Normalizes Express query parameters by:\n * 1. Converting array values to their first element (Express can provide array for repeated params)\n * 2. Removing undefined values and nested objects (Express can parse nested query strings like `?foo[bar]=baz` into objects)\n * 3. Ensuring all values are strings\n *\n * @param query - The raw query object from Express request\n * @returns A normalized query object with single string values\n */\nconst normalizeQueryParameters = (\n  query: Request['query']\n): Record<string, string> => {\n  return Object.fromEntries(\n    Object.entries(query)\n      .map(([key, value]) => [\n        key,\n        Array.isArray(value)\n          ? value[0]\n          : typeof value === 'object' && value !== null\n            ? null // Skip nested objects\n            : String(value),\n      ])\n      .filter(\n        (entry): entry is [string, string] =>\n          entry[1] !== null &&\n          entry[1] !== undefined &&\n          entry[1] !== 'undefined'\n      )\n  )\n}\n\n/**\n * Options for creating an Express router with scoped FlowgladServer instances.\n */\nexport interface ExpressRouterOptions\n  extends RequestHandlerOptions<Request> {\n  /**\n   * Optional Express middleware to run before the Flowglad handler.\n   */\n  middleware?: RequestHandler[]\n}\n\n/**\n * Creates an Express router for Flowglad API routes.\n *\n * @param options - Configuration options including customer ID extraction and FlowgladServer factory\n * @returns An Express router configured for Flowglad routes\n */\nexport const expressRouter = (\n  options: ExpressRouterOptions\n): Router => {\n  const router = Router()\n  const handler = requestHandler(options)\n\n  // Apply middleware if provided\n  if (options.middleware) {\n    router.use(...options.middleware)\n  }\n\n  // Handle all routes\n  router.all('*', async (req, res) => {\n    const pathFragments = req.path\n      .split('/')\n      .filter((fragment) => fragment !== '')\n\n    const result = await handler(\n      {\n        path: pathFragments,\n        method: req.method as HTTPMethod,\n        query:\n          req.method === 'GET'\n            ? normalizeQueryParameters(req.query)\n            : undefined,\n        body: req.method !== 'GET' ? req.body : undefined,\n      },\n      req\n    )\n\n    res.status(result.status).json({\n      error: result.error,\n      data: result.data,\n    })\n  })\n\n  return router\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,qBAA0D;AAC1D,4BAGO;AAWP,MAAM,2BAA2B,CAC/B,UAC2B;AAC3B,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,KAAK,EACjB,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM;AAAA,MACrB;AAAA,MACA,MAAM,QAAQ,KAAK,IACf,MAAM,CAAC,IACP,OAAO,UAAU,YAAY,UAAU,OACrC,OACA,OAAO,KAAK;AAAA,IACpB,CAAC,EACA;AAAA,MACC,CAAC,UACC,MAAM,CAAC,MAAM,QACb,MAAM,CAAC,MAAM,UACb,MAAM,CAAC,MAAM;AAAA,IACjB;AAAA,EACJ;AACF;AAmBO,MAAM,gBAAgB,CAC3B,YACW;AACX,QAAM,aAAS,uBAAO;AACtB,QAAM,cAAU,sCAAe,OAAO;AAGtC,MAAI,QAAQ,YAAY;AACtB,WAAO,IAAI,GAAG,QAAQ,UAAU;AAAA,EAClC;AAGA,SAAO,IAAI,KAAK,CAAO,KAAK,QAAQ;AAClC,UAAM,gBAAgB,IAAI,KACvB,MAAM,GAAG,EACT,OAAO,CAAC,aAAa,aAAa,EAAE;AAEvC,UAAM,SAAS,MAAM;AAAA,MACnB;AAAA,QACE,MAAM;AAAA,QACN,QAAQ,IAAI;AAAA,QACZ,OACE,IAAI,WAAW,QACX,yBAAyB,IAAI,KAAK,IAClC;AAAA,QACN,MAAM,IAAI,WAAW,QAAQ,IAAI,OAAO;AAAA,MAC1C;AAAA,MACA;AAAA,IACF;AAEA,QAAI,OAAO,OAAO,MAAM,EAAE,KAAK;AAAA,MAC7B,OAAO,OAAO;AAAA,MACd,MAAM,OAAO;AAAA,IACf,CAAC;AAAA,EACH,EAAC;AAED,SAAO;AACT;","names":[]}