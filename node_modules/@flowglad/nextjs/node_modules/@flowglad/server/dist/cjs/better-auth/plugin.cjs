"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var plugin_exports = {};
__export(plugin_exports, {
  createFlowgladCustomerForOrganization: () => createFlowgladCustomerForOrganization,
  flowgladPlugin: () => flowgladPlugin
});
module.exports = __toCommonJS(plugin_exports);
var import_plugins = require("better-auth/plugins");
var import_FlowgladServer = require('../FlowgladServer.cjs');
var import_endpoints = require('./endpoints.cjs');
const getDefaultCustomer = (session, customerType) => __async(null, null, function* () {
  if (customerType === "organization") {
    const orgId = session.user.organizationId;
    if (!orgId) {
      throw new Error("Organization ID not found in session");
    }
    return {
      externalId: orgId,
      name: session.user.name || "Organization",
      email: session.user.email || ""
    };
  }
  if (!session.user.email) {
    throw new Error(
      "User email is required to create Flowglad customer"
    );
  }
  return {
    externalId: session.user.id,
    name: session.user.name || "",
    email: session.user.email
  };
});
const createFlowgladCustomer = (options, session) => __async(null, null, function* () {
  const customerType = options.customerType || "user";
  const customerInfo = options.getCustomer ? yield options.getCustomer(session) : yield getDefaultCustomer(session, customerType);
  const apiKey = options.apiKey || process.env.FLOWGLAD_SECRET_KEY;
  const flowgladServerConfig = {
    customerExternalId: customerInfo.externalId,
    getCustomerDetails: () => __async(null, null, function* () {
      return {
        name: customerInfo.name,
        email: customerInfo.email
      };
    })
  };
  if (apiKey) {
    flowgladServerConfig.apiKey = apiKey;
  }
  if (options.baseURL) {
    flowgladServerConfig.baseURL = options.baseURL;
  }
  const flowgladServer = new import_FlowgladServer.FlowgladServer(flowgladServerConfig);
  yield flowgladServer.findOrCreateCustomer();
});
const reportCustomerCreateError = (options, params) => __async(null, null, function* () {
  if (options.onCustomerCreateError) {
    yield options.onCustomerCreateError(params);
    return;
  }
  if (params.hook === "afterSignUp") {
    console.error(
      "Failed to create Flowglad customer after sign-up:",
      params.error
    );
    return;
  }
  console.error(
    "Failed to create Flowglad customer after organization creation:",
    params.error
  );
});
const createFlowgladCustomerForOrganization = (options, params) => __async(null, null, function* () {
  var _a;
  const {
    organizationId,
    userId,
    userEmail,
    userName,
    organizationName,
    organizationEmail
  } = params;
  const session = {
    user: {
      id: userId,
      email: organizationEmail != null ? organizationEmail : userEmail,
      name: (_a = organizationName != null ? organizationName : userName) != null ? _a : null,
      organizationId
    }
  };
  yield createFlowgladCustomer(options, session);
});
const flowgladPlugin = (options) => {
  const plugin = {
    id: "flowglad",
    endpoints: __spreadProps(__spreadValues({
      getExternalId: (0, import_endpoints.createGetExternalIdEndpoint)(options)
    }, (0, import_endpoints.createBillingEndpoints)(options)), {
      getPricingModel: (0, import_endpoints.createGetPricingModelEndpoint)(options)
    }),
    hooks: {
      after: [
        {
          matcher: (context) => {
            return context.path === "/sign-up" || context.path === "/sign-up/email";
          },
          handler: (0, import_plugins.createAuthMiddleware)((ctx) => __async(null, null, function* () {
            var _a;
            const returned = ctx.context.returned;
            if (!((_a = returned == null ? void 0 : returned.user) == null ? void 0 : _a.id)) {
              return;
            }
            const session = {
              user: {
                id: returned.user.id,
                name: returned.user.name || null,
                email: returned.user.email || null,
                organizationId: null
              }
            };
            const customerType = options.customerType || "user";
            if (customerType !== "user") {
              return;
            }
            try {
              yield createFlowgladCustomer(options, session);
            } catch (error) {
              yield reportCustomerCreateError(options, {
                hook: "afterSignUp",
                customerType,
                session,
                error
              });
            }
          }))
        },
        {
          matcher: (context) => {
            return context.path === "/organization/create";
          },
          handler: (0, import_plugins.createAuthMiddleware)((ctx) => __async(null, null, function* () {
            var _a, _b, _c, _d, _e;
            const returned = ctx.context.returned;
            if (!((_a = returned == null ? void 0 : returned.organization) == null ? void 0 : _a.id)) {
              return;
            }
            const session = ctx.context.session;
            if (!(session == null ? void 0 : session.user)) {
              return;
            }
            const customerType = options.customerType || "user";
            if (customerType !== "organization") {
              return;
            }
            const organizationId = returned.organization.id;
            const organizationName = typeof returned.organization.name === "string" ? returned.organization.name : "Organization";
            const organizationEmail = (0, import_endpoints.isAdapterLike)(ctx.context.adapter) && typeof session.user.id === "string" ? (_d = (_c = (_b = yield (0, import_endpoints.getOrganizationDetails)({
              adapter: ctx.context.adapter,
              organizationId,
              userId: session.user.id,
              creatorRole: (0, import_endpoints.getCreatorRoleFromOrgOptions)(
                (0, import_endpoints.getOrgOptionsFromCtxContext)(ctx.context)
              )
            })) == null ? void 0 : _b.email) != null ? _c : session.user.email) != null ? _d : null : (_e = session.user.email) != null ? _e : null;
            const orgSession = {
              user: {
                id: session.user.id,
                // For org customers, we want Flowglad customer name/email to
                // default to org name + owner email (best-effort).
                name: organizationName,
                email: organizationEmail,
                organizationId
              }
            };
            try {
              yield createFlowgladCustomer(options, orgSession);
            } catch (error) {
              yield reportCustomerCreateError(options, {
                hook: "afterOrganizationCreate",
                customerType,
                session: orgSession,
                error
              });
            }
          }))
        }
      ]
    }
  };
  return plugin;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createFlowgladCustomerForOrganization,
  flowgladPlugin
});
//# sourceMappingURL=plugin.cjs.map