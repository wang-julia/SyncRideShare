"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var serverUtils_exports = {};
__export(serverUtils_exports, {
  getSessionFromNextAuth: () => getSessionFromNextAuth,
  getSessionFromParams: () => getSessionFromParams,
  parseErrorStringToErrorObject: () => parseErrorStringToErrorObject,
  sessionFromBetterAuth: () => sessionFromBetterAuth,
  sessionFromClerkAuth: () => sessionFromClerkAuth,
  sessionFromSupabaseAuth: () => sessionFromSupabaseAuth
});
module.exports = __toCommonJS(serverUtils_exports);
var import_zod = require("zod");
const getSessionFromNextAuth = (params) => __async(null, null, function* () {
  let coreCustomerUser = null;
  const session = yield params.nextAuth.auth();
  if (session == null ? void 0 : session.user) {
    if (params.nextAuth.customerFromAuth) {
      coreCustomerUser = yield params.nextAuth.customerFromAuth(session);
    } else {
      if (!session.user.email) {
        throw new Error(
          "FlowgladError: NextAuth session has no email. Please provide an extractUserIdFromSession function to extract the userId from the session, or include email on your sessions."
        );
      }
      coreCustomerUser = {
        externalId: session.user.email,
        name: session.user.name || "",
        email: session.user.email || ""
      };
    }
  }
  return coreCustomerUser;
});
const getSessionFromNextAuth4 = (params) => __async(null, null, function* () {
  const session = yield params.nextAuth.auth();
  return session;
});
const sessionFromSupabaseAuth = (params) => __async(null, null, function* () {
  let coreCustomerUser = null;
  const {
    data: { user }
  } = yield (yield params.supabaseAuth.client()).auth.getUser();
  if (user) {
    coreCustomerUser = {
      externalId: user.id,
      name: user.user_metadata.name || "",
      email: user.email || ""
    };
  }
  return coreCustomerUser;
});
const sessionFromClerkAuth = (params) => __async(null, null, function* () {
  let coreCustomerUser = null;
  const session = yield params.clerk.currentUser();
  if (params.clerk.customerFromCurrentUser && session) {
    coreCustomerUser = yield params.clerk.customerFromCurrentUser(session);
  } else if (session) {
    coreCustomerUser = {
      externalId: session.id,
      name: session.firstName || "",
      email: session.emailAddresses[0].emailAddress || ""
    };
  }
  return coreCustomerUser;
});
const sessionFromBetterAuth = (params) => __async(null, null, function* () {
  let coreCustomerUser = null;
  const session = yield params.betterAuth.getSession();
  if (session == null ? void 0 : session.user) {
    if (params.betterAuth.customerFromSession) {
      coreCustomerUser = yield params.betterAuth.customerFromSession(session);
    } else {
      coreCustomerUser = {
        externalId: session.user.id,
        name: session.user.name || "",
        email: session.user.email || ""
      };
    }
  }
  return coreCustomerUser;
});
const getSessionFromParams = (params, scopedCustomerExternalId) => __async(null, null, function* () {
  if (scopedCustomerExternalId !== void 0) {
    const hasOtherAuth = "nextAuth" in params || "supabaseAuth" in params || "clerk" in params || "betterAuth" in params || "getRequestingCustomer" in params && params.getRequestingCustomer;
    if (hasOtherAuth) {
      throw new Error(
        "FlowgladError: customerExternalId cannot be used with other authentication methods."
      );
    }
    if (!scopedCustomerExternalId.trim()) {
      throw new Error(
        "FlowgladError: customerExternalId cannot be empty"
      );
    }
    return {
      externalId: scopedCustomerExternalId,
      name: "",
      email: ""
    };
  }
  let coreCustomerUser = null;
  const providerCount = [
    "nextAuth" in params,
    "supabaseAuth" in params,
    "clerk" in params,
    "betterAuth" in params
  ].filter(Boolean).length;
  if (providerCount > 1) {
    throw new Error(
      "FlowgladError: Only one of nextAuth, supabaseAuth, clerk, or betterAuth may be defined at a time."
    );
  }
  if ("getRequestingCustomer" in params && params.getRequestingCustomer) {
    coreCustomerUser = yield params.getRequestingCustomer();
  } else {
    if ("nextAuth" in params) {
      coreCustomerUser = yield getSessionFromNextAuth(params);
    } else if ("supabaseAuth" in params) {
      coreCustomerUser = yield sessionFromSupabaseAuth(params);
    } else if ("clerk" in params) {
      coreCustomerUser = yield sessionFromClerkAuth(params);
    } else if ("betterAuth" in params) {
      coreCustomerUser = yield sessionFromBetterAuth(params);
    }
  }
  const customerSchema = import_zod.z.object({
    externalId: import_zod.z.string().min(1),
    name: import_zod.z.string(),
    email: import_zod.z.email()
  });
  const parsedCustomer = customerSchema.safeParse(coreCustomerUser);
  if (!parsedCustomer.success) {
    throw new Error(
      `Unable to derive requesting customer from session. Please check your flowgladServer constructor, in your server's flowglad.ts file. This is an issue with how your user's session data on the server is being mapped to Flowglad requesting customer input.

Issues:
${parsedCustomer.error.issues.map((issue) => `- ${issue.path}: ${issue.message}`).join(`
`)}.

Received input:
` + JSON.stringify(coreCustomerUser)
    );
  }
  return parsedCustomer.data;
});
const parseErrorStringToErrorObject = (errorString) => {
  let [errorCode, ...errorJsonParts] = errorString.split(" ");
  if (isNaN(Number(errorCode))) {
    errorCode = "Unknown";
  }
  let errorJson = {};
  try {
    errorJson = JSON.parse(errorJsonParts.join(" "));
  } catch (e) {
    errorJson = {
      message: errorString
    };
  }
  return {
    code: errorCode,
    json: errorJson
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  getSessionFromNextAuth,
  getSessionFromParams,
  parseErrorStringToErrorObject,
  sessionFromBetterAuth,
  sessionFromClerkAuth,
  sessionFromSupabaseAuth
});
//# sourceMappingURL=serverUtils.cjs.map