{"version":3,"sources":["../../src/requestHandler.ts"],"sourcesContent":["import {\n  type AuthenticatedActionKey,\n  FlowgladActionKey,\n  type HTTPMethod,\n  type HybridActionKey,\n} from '@flowglad/shared'\nimport type { FlowgladServer } from './FlowgladServer'\nimport { FlowgladServerAdmin } from './FlowgladServerAdmin'\nimport {\n  hybridRouteToHandlerMap,\n  isHybridActionKey,\n  routeToHandlerMap,\n} from './subrouteHandlers'\nimport type {\n  HybridSubRouteHandler,\n  SubRouteHandler,\n} from './subrouteHandlers/types'\n\n/**\n * Input for the request handler.\n */\nexport interface RequestHandlerInput {\n  /**\n   * The path of the request.\n   * @example \"/customers/123\" => [\"customers\", \"123\"]\n   */\n  path: string[]\n  /**\n   * The method of the request.\n   * @example \"GET\"\n   */\n  method: HTTPMethod\n  /**\n   * The parsed query parameters of the request.\n   * @example { \"name\": \"John\", \"age\": \"30\" }\n   */\n  query?: Record<string, string>\n  /**\n   * The body of the request.\n   * @example { \"name\": \"John\", \"age\": \"30\" }\n   */\n  body?: unknown\n}\n\nexport interface RequestHandlerOutput {\n  status: number\n  data?: unknown\n  error?: unknown\n}\n\n/**\n * Options for creating a request handler with per-request scoped FlowgladServer instances.\n *\n * This interface supports the customer ID extraction pattern where customer identification\n * and FlowgladServer construction are separated for better flexibility and testability.\n *\n * @typeParam TRequest - The framework-specific request type (e.g., Express Request, NextRequest)\n */\nexport interface RequestHandlerOptions<TRequest> {\n  /**\n   * Function to extract the customer external ID from the request.\n   * The customerExternalId should be from YOUR app's database (e.g., user.id or organization.id),\n   * NOT Flowglad's customer ID.\n   *\n   * @param req - The framework-specific request object\n   * @returns The customer external ID from your app's database\n   */\n  getCustomerExternalId: (req: TRequest) => Promise<string>\n  /**\n   * Function that creates a FlowgladServer instance for a specific customer.\n   * This function will be called for each request with the extracted customer ID.\n   *\n   * @param customerExternalId - The customer's external ID\n   * @returns A FlowgladServer instance scoped to that customer\n   */\n  flowglad: (\n    customerExternalId: string\n  ) => Promise<FlowgladServer> | FlowgladServer\n  /**\n   * API key for hybrid routes (routes that work with or without authentication).\n   * Required for hybrid routes. Falls back to process.env.FLOWGLAD_SECRET_KEY.\n   */\n  apiKey?: string\n  /**\n   * Base URL for the Flowglad API.\n   */\n  baseURL?: string\n  /**\n   * Function to run when an error occurs during request handling.\n   */\n  onError?: (error: unknown) => void\n  /**\n   * Side effect to run before the request is processed.\n   */\n  beforeRequest?: () => Promise<void>\n  /**\n   * Side effect to run after the request is processed.\n   */\n  afterRequest?: () => Promise<void>\n}\n\nexport class RequestHandlerError extends Error {\n  constructor(\n    message: string,\n    public status: number = 400\n  ) {\n    super(message)\n    this.name = 'RequestHandlerError'\n  }\n}\n\n/**\n * Creates a request handler that extracts customer ID and creates scoped FlowgladServer instances.\n *\n * @typeParam TRequest - The framework-specific request type (e.g., Express Request, NextRequest)\n */\nexport const requestHandler = <TRequest = unknown>(\n  options: RequestHandlerOptions<TRequest>\n) => {\n  const {\n    getCustomerExternalId,\n    flowglad,\n    apiKey,\n    baseURL,\n    onError,\n    beforeRequest,\n    afterRequest,\n  } = options\n\n  return async (\n    input: RequestHandlerInput,\n    request: TRequest\n  ): Promise<RequestHandlerOutput> => {\n    try {\n      if (beforeRequest) {\n        await beforeRequest()\n      }\n\n      // Validate path BEFORE attempting auth - this allows hybrid routes to\n      // return proper errors without auth throwing first\n      const joinedPath = input.path.join('/') as FlowgladActionKey\n\n      if (!Object.values(FlowgladActionKey).includes(joinedPath)) {\n        throw new RequestHandlerError(\n          `\"${joinedPath}\" is not a valid Flowglad API path`,\n          404\n        )\n      }\n\n      const data = input.method === 'GET' ? input.query : input.body\n\n      // ═══════════════════════════════════════════════════════════════════════\n      // HYBRID ROUTE HANDLING\n      // Check if this is a hybrid route (auth optional, graceful fallback)\n      // ═══════════════════════════════════════════════════════════════════════\n      if (isHybridActionKey(joinedPath)) {\n        const resolvedApiKey =\n          apiKey || process.env.FLOWGLAD_SECRET_KEY\n        if (!resolvedApiKey) {\n          throw new RequestHandlerError(\n            'API key required for this route. Provide apiKey option or set FLOWGLAD_SECRET_KEY environment variable.',\n            500\n          )\n        }\n\n        const flowgladServerAdmin = new FlowgladServerAdmin({\n          apiKey: resolvedApiKey,\n          baseURL: baseURL || process.env.FLOWGLAD_BASE_URL,\n        })\n\n        // ─────────────────────────────────────────────────────────────────────\n        // TRY/CATCH SCOPE: Only catches errors from auth layer\n        // These errors indicate \"user is not authenticated\" - expected behavior\n        // ─────────────────────────────────────────────────────────────────────\n        let flowgladServer: FlowgladServer | null = null\n        try {\n          const customerExternalId =\n            await getCustomerExternalId(request)\n          flowgladServer = await flowglad(customerExternalId)\n        } catch (authError) {\n          // ✓ CAUGHT: Auth failed - this is EXPECTED for hybrid routes\n          // flowgladServer remains null, handler will use default pricing path\n          //\n          // This catch block handles ALL errors from getCustomerExternalId and flowglad:\n          // - No session/token present\n          // - Invalid/expired session/token\n          // - Database errors looking up user\n          // - Any other auth-layer failure\n          //\n          // All of these result in the same behavior: treat as unauthenticated\n        }\n\n        const handler = hybridRouteToHandlerMap[joinedPath]\n        const result = await (\n          handler as HybridSubRouteHandler<typeof joinedPath>\n        )(\n          {\n            method: input.method as any,\n            data: data as any,\n          },\n          {\n            flowgladServer,\n            flowgladServerAdmin,\n          }\n        )\n\n        if (afterRequest) {\n          await afterRequest()\n        }\n\n        return {\n          status: result.status,\n          data: result.data,\n          error: result.error,\n        }\n      }\n\n      // ═══════════════════════════════════════════════════════════════════════\n      // AUTHENTICATED ROUTE HANDLING (existing behavior)\n      // NO TRY/CATCH here - auth errors propagate and return appropriate status\n      // ═══════════════════════════════════════════════════════════════════════\n      const handler =\n        routeToHandlerMap[joinedPath as AuthenticatedActionKey]\n      if (!handler) {\n        throw new RequestHandlerError(\n          `\"${joinedPath}\" is not a valid Flowglad API path`,\n          404\n        )\n      }\n\n      const customerExternalId = await getCustomerExternalId(request)\n      const flowgladServer = await flowglad(customerExternalId)\n\n      // We need to use a type assertion here because TypeScript cannot narrow the type\n      // of joinedPath to a specific FlowgladActionKey at compile time, even though\n      // we've validated it at runtime\n      const result = await (\n        handler as SubRouteHandler<typeof joinedPath>\n      )(\n        {\n          method: input.method as any,\n          data: data as any,\n        },\n        flowgladServer\n      )\n\n      if (afterRequest) {\n        await afterRequest()\n      }\n\n      return {\n        status: result.status,\n        data: result.data,\n        error: result.error,\n      }\n    } catch (error) {\n      if (onError) {\n        onError(error)\n      }\n\n      if (error instanceof RequestHandlerError) {\n        return {\n          status: error.status,\n          error: { message: error.message },\n        }\n      }\n      if ((error as any).message) {\n        return {\n          status: (error as any).status ?? 500,\n          error: { message: (error as any).message },\n        }\n      }\n      return {\n        status: 400,\n        error: { message: 'Internal server error' },\n      }\n    }\n  }\n}\n"],"mappings":"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","names":["flowgladServer","customerExternalId","handler","result"]}