"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var FlowgladServer_exports = {};
__export(FlowgladServer_exports, {
  FlowgladServer: () => FlowgladServer
});
module.exports = __toCommonJS(FlowgladServer_exports);
var import_node = require("@flowglad/node");
var import_shared = require("@flowglad/shared");
var import_serverUtils = require('./serverUtils.cjs');
class FlowgladServer {
  constructor(createHandlerParams) {
    this.getRequestingCustomerId = () => __async(this, null, function* () {
      var _a;
      if ("getRequestingCustomer" in this.createHandlerParams && this.createHandlerParams.getRequestingCustomer) {
        const customer = yield this.createHandlerParams.getRequestingCustomer();
        if (customer) {
          return customer.externalId;
        }
      }
      const session = yield (0, import_serverUtils.getSessionFromParams)(
        this.createHandlerParams,
        (_a = this.scopedParams) == null ? void 0 : _a.customerExternalId
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      return session.externalId;
    });
    this.getSession = () => __async(this, null, function* () {
      var _a;
      return (0, import_serverUtils.getSessionFromParams)(
        this.createHandlerParams,
        (_a = this.scopedParams) == null ? void 0 : _a.customerExternalId
      );
    });
    this.getBilling = () => __async(this, null, function* () {
      var _a;
      const customer = yield this.findOrCreateCustomer();
      const rawBilling = yield this.flowgladNode.customers.retrieveBilling(
        customer.externalId
      );
      const currentSubscriptionsWithExperimental = (_a = rawBilling.currentSubscriptions) != null ? _a : [];
      return __spreadProps(__spreadValues({}, rawBilling), {
        checkFeatureAccess: (0, import_shared.constructCheckFeatureAccess)(
          currentSubscriptionsWithExperimental
        ),
        checkUsageBalance: (0, import_shared.constructCheckUsageBalance)(
          currentSubscriptionsWithExperimental
        ),
        getProduct: (0, import_shared.constructGetProduct)(rawBilling.pricingModel),
        getPrice: (0, import_shared.constructGetPrice)(rawBilling.pricingModel),
        hasPurchased: (0, import_shared.constructHasPurchased)(
          rawBilling.pricingModel,
          rawBilling.purchases
        )
      });
    });
    this.findOrCreateCustomer = () => __async(this, null, function* () {
      var _a;
      let customer = null;
      try {
        const getResult = yield this.getCustomer();
        customer = getResult.customer;
      } catch (error) {
        const errorCode = (_a = error == null ? void 0 : error.error) == null ? void 0 : _a.code;
        if (errorCode === "NOT_FOUND") {
          if (this.scopedParams) {
            const customerDetails = yield this.scopedParams.getCustomerDetails(
              this.scopedParams.customerExternalId
            );
            const createResult = yield this.createCustomer({
              customer: {
                email: customerDetails.email,
                name: customerDetails.name,
                externalId: this.scopedParams.customerExternalId
              }
            });
            customer = createResult.data.customer;
          } else {
            const session = yield (0, import_serverUtils.getSessionFromParams)(
              this.createHandlerParams,
              void 0
            );
            if (!session) {
              throw new Error("User not authenticated");
            }
            const createResult = yield this.createCustomer({
              customer: {
                email: session.email,
                name: session.name,
                externalId: session.externalId
              }
            });
            customer = createResult.data.customer;
          }
        } else {
          throw error;
        }
      }
      if (!customer) {
        throw new Error("Customer not found");
      }
      return customer;
    });
    this.getCustomer = () => __async(this, null, function* () {
      var _a;
      const session = yield (0, import_serverUtils.getSessionFromParams)(
        this.createHandlerParams,
        (_a = this.scopedParams) == null ? void 0 : _a.customerExternalId
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      return this.flowgladNode.customers.retrieve(session.externalId);
    });
    this.createCustomer = (params) => __async(this, null, function* () {
      return yield this.flowgladNode.customers.create(params);
    });
    /**
     * Create a checkout session.
     * You can provide either `priceId` or `priceSlug` (but not both).
     * @param params - Checkout session parameters. Must include either `priceId` or `priceSlug`, plus `successUrl` and `cancelUrl`.
     * @returns The created checkout session with a URL for redirecting the customer.
     */
    this.createCheckoutSession = (params) => __async(this, null, function* () {
      var _a;
      const session = yield (0, import_serverUtils.getSessionFromParams)(
        this.createHandlerParams,
        (_a = this.scopedParams) == null ? void 0 : _a.customerExternalId
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      const parsedParams = import_shared.createProductCheckoutSessionSchema.parse(__spreadProps(__spreadValues({}, params), {
        type: "product",
        customerExternalId: session.externalId
      }));
      return this.flowgladNode.checkoutSessions.create({
        checkoutSession: __spreadProps(__spreadValues({}, parsedParams), {
          type: "product",
          customerExternalId: session.externalId
        })
      });
    });
    this.updateCustomer = (params) => __async(this, null, function* () {
      var _a;
      const session = yield (0, import_serverUtils.getSessionFromParams)(
        this.createHandlerParams,
        (_a = this.scopedParams) == null ? void 0 : _a.customerExternalId
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      return this.flowgladNode.customers.update(
        session.externalId,
        params
      );
    });
    this.createAddPaymentMethodCheckoutSession = (params) => __async(this, null, function* () {
      var _a;
      const session = yield (0, import_serverUtils.getSessionFromParams)(
        this.createHandlerParams,
        (_a = this.scopedParams) == null ? void 0 : _a.customerExternalId
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      const parsedParams = import_shared.createAddPaymentMethodCheckoutSessionSchema.parse(params);
      return yield this.flowgladNode.checkoutSessions.create({
        checkoutSession: __spreadProps(__spreadValues({}, parsedParams), {
          type: "add_payment_method",
          customerExternalId: session.externalId
        })
      });
    });
    this.createActivateSubscriptionCheckoutSession = (params) => __async(this, null, function* () {
      var _a;
      const session = yield (0, import_serverUtils.getSessionFromParams)(
        this.createHandlerParams,
        (_a = this.scopedParams) == null ? void 0 : _a.customerExternalId
      );
      if (!session) {
        throw new Error("User not authenticated");
      }
      const parsedParams = import_shared.createActivateSubscriptionCheckoutSessionSchema.parse(params);
      return yield this.flowgladNode.checkoutSessions.create({
        checkoutSession: __spreadProps(__spreadValues({}, parsedParams), {
          type: "activate_subscription",
          customerExternalId: session.externalId
        })
      });
    });
    this.cancelSubscription = (params) => __async(this, null, function* () {
      const { subscription } = yield this.flowgladNode.subscriptions.retrieve(params.id);
      const { customer } = yield this.getCustomer();
      if (subscription.customerId !== customer.id) {
        throw new Error("Subscription is not owned by the current user");
      }
      if (subscription.status === "canceled") {
        throw new Error("Subscription is already canceled");
      }
      return this.flowgladNode.subscriptions.cancel(params.id, {
        cancellation: params.cancellation
      });
    });
    /**
     * Uncancel a subscription that is scheduled for cancellation.
     *
     * @param params - Parameters containing the subscription ID to uncancel
     * @returns The uncanceled subscription
     * @throws {Error} If the subscription is not owned by the authenticated customer
     *
     * Note: This method is idempotent. If the subscription is not in 'cancellation_scheduled'
     * status, it returns the subscription without modification.
     */
    this.uncancelSubscription = (params) => __async(this, null, function* () {
      const { subscription } = yield this.flowgladNode.subscriptions.retrieve(params.id);
      const { customer } = yield this.getCustomer();
      if (subscription.customerId !== customer.id) {
        throw new Error("Subscription is not owned by the current user");
      }
      if (subscription.status !== "cancellation_scheduled") {
        return { subscription };
      }
      return this.flowgladNode.subscriptions.uncancel(params.id, {
        body: {}
      });
    });
    /**
     * Adjust a subscription to a different price.
     *
     * @example
     * // Simplest: adjust by price slug (quantity defaults to 1)
     * await flowglad.adjustSubscription({ priceSlug: 'pro-monthly' })
     *
     * // With quantity
     * await flowglad.adjustSubscription({ priceSlug: 'pro-monthly', quantity: 5 })
     *
     * // Using price ID
     * await flowglad.adjustSubscription({ priceId: 'price_abc123', quantity: 3 })
     *
     * // With timing override
     * await flowglad.adjustSubscription({
     *   priceSlug: 'pro-monthly',
     *   timing: 'at_end_of_current_billing_period'
     * })
     *
     * // Explicit subscription ID (for multi-subscription customers)
     * await flowglad.adjustSubscription({
     *   priceSlug: 'pro-monthly',
     *   subscriptionId: 'sub_123'
     * })
     *
     * // Complex adjustment with multiple items
     * await flowglad.adjustSubscription({
     *   subscriptionItems: [
     *     { priceSlug: 'base-plan', quantity: 1 },
     *     { priceSlug: 'addon-storage', quantity: 3 },
     *   ],
     *   timing: 'immediately',
     *   prorate: true,
     * })
     *
     * @param params - Adjustment parameters (one of three forms)
     * @param params.priceSlug - Adjust to a price by slug (mutually exclusive with priceId and subscriptionItems)
     * @param params.priceId - Adjust to a price by ID (mutually exclusive with priceSlug and subscriptionItems)
     * @param params.subscriptionItems - Array of items for multi-item adjustments (mutually exclusive with priceSlug and priceId)
     * @param params.quantity - Number of units for single-price adjustments (default: 1)
     * @param params.subscriptionId - Subscription ID (auto-resolves if customer has exactly 1 subscription)
     * @param params.timing - 'immediately' | 'at_end_of_current_billing_period' | 'auto' (default: 'auto')
     *   - 'auto': Upgrades happen immediately, downgrades at end of period
     *   - 'immediately': Apply change now with proration
     *   - 'at_end_of_current_billing_period': Apply change at next billing period
     * @param params.prorate - Whether to prorate (default: true for immediate, false for end-of-period)
     * @returns The adjusted subscription and its items
     * @throws {Error} If customer has no active subscriptions
     * @throws {Error} If customer has multiple subscriptions and subscriptionId not provided
     * @throws {Error} If the subscription is not owned by the authenticated customer
     */
    this.adjustSubscription = (params) => __async(this, null, function* () {
      var _a, _b, _c, _d;
      const parsedParams = import_shared.adjustSubscriptionParamsSchema.parse(params);
      let subscriptionId = parsedParams.subscriptionId;
      if (!subscriptionId) {
        const billing = yield this.getBilling();
        const currentSubscriptions = (_a = billing.currentSubscriptions) != null ? _a : [];
        if (currentSubscriptions.length === 0) {
          throw new Error(
            "No active subscription found for this customer"
          );
        }
        if (currentSubscriptions.length > 1) {
          throw new Error(
            "Customer has multiple active subscriptions. Please specify subscriptionId in params."
          );
        }
        subscriptionId = currentSubscriptions[0].id;
      }
      const { subscription } = yield this.flowgladNode.subscriptions.retrieve(subscriptionId);
      const { customer } = yield this.getCustomer();
      if (subscription.customerId !== customer.id) {
        throw new Error("Subscription is not owned by the current user");
      }
      const timing = (_b = parsedParams.timing) != null ? _b : import_shared.subscriptionAdjustmentTiming.Auto;
      const prorate = parsedParams.prorate;
      let newSubscriptionItems;
      if ("subscriptionItems" in parsedParams && parsedParams.subscriptionItems) {
        newSubscriptionItems = parsedParams.subscriptionItems.map(
          (item) => {
            var _a2;
            return __spreadProps(__spreadValues({}, item), {
              quantity: (_a2 = item.quantity) != null ? _a2 : 1
            });
          }
        );
      } else if ("priceSlug" in parsedParams && parsedParams.priceSlug) {
        newSubscriptionItems = [
          {
            priceSlug: parsedParams.priceSlug,
            quantity: (_c = parsedParams.quantity) != null ? _c : 1
          }
        ];
      } else if ("priceId" in parsedParams && parsedParams.priceId) {
        newSubscriptionItems = [
          {
            priceId: parsedParams.priceId,
            quantity: (_d = parsedParams.quantity) != null ? _d : 1
          }
        ];
      } else {
        throw new Error(
          "Invalid params: must provide priceSlug, priceId, or subscriptionItems"
        );
      }
      const adjustment = timing === import_shared.subscriptionAdjustmentTiming.AtEndOfCurrentBillingPeriod ? {
        timing,
        newSubscriptionItems
      } : {
        timing,
        newSubscriptionItems,
        prorateCurrentBillingPeriod: prorate != null ? prorate : true
      };
      return this.flowgladNode.subscriptions.adjust(subscriptionId, {
        adjustment
      });
    });
    this.createSubscription = (params) => __async(this, null, function* () {
      var _a;
      const customer = yield this.findOrCreateCustomer();
      const rawParams = __spreadProps(__spreadValues({}, params), {
        quantity: (_a = params.quantity) != null ? _a : 1,
        customerId: customer.id
      });
      return this.flowgladNode.subscriptions.create(rawParams);
    });
    /**
     * Create a usage event for a customer.
     * NOTE: this method makes two API calls, including one to get the customer.
     * If you are to create usages en masse with minimum latency,
     * you should use `FlowgladServerAdmin.createUsageEvent` instead.
     * @param params - The parameters for the usage event.
     * @returns The created usage event.
     */
    this.createUsageEvent = (params) => __async(this, null, function* () {
      var _a, _b;
      const parsedParams = import_shared.createUsageEventSchema.parse(params);
      return this.flowgladNode.usageEvents.create({
        usageEvent: __spreadProps(__spreadValues({}, parsedParams), {
          properties: (_a = parsedParams.properties) != null ? _a : void 0,
          usageDate: (_b = parsedParams.usageDate) != null ? _b : void 0
        })
      });
    });
    /**
     * Create multiple usage events in a single request.
     * NOTE: this method is more efficient than calling `createUsageEvent` multiple times.
     * @param params - The parameters containing an array of usage events.
     * @returns The created usage events.
     * @throws {Error} If any subscription in the bulk request is not owned by the authenticated customer.
     */
    this.bulkCreateUsageEvents = (params) => __async(this, null, function* () {
      var _a, _b;
      const parsedParams = import_shared.bulkCreateUsageEventsSchema.parse(params);
      const billing = yield this.getBilling();
      const uniqueSubscriptionIds = [
        ...new Set(
          parsedParams.usageEvents.map((e) => e.subscriptionId)
        )
      ];
      const customerSubscriptionIds = (_b = (_a = billing.currentSubscriptions) == null ? void 0 : _a.map((sub) => sub.id)) != null ? _b : [];
      for (const subscriptionId of uniqueSubscriptionIds) {
        if (!customerSubscriptionIds.includes(subscriptionId)) {
          throw new Error(
            `Subscription ${subscriptionId} is not found among the customer's current subscriptions`
          );
        }
      }
      const usageEvents = parsedParams.usageEvents.map(
        (usageEvent) => {
          var _a2, _b2;
          return __spreadProps(__spreadValues({}, usageEvent), {
            properties: (_a2 = usageEvent.properties) != null ? _a2 : void 0,
            usageDate: (_b2 = usageEvent.usageDate) != null ? _b2 : void 0
          });
        }
      );
      return this.flowgladNode.post("/api/v1/usage-events/bulk", {
        body: { usageEvents }
      });
    });
    this.getPricingModel = () => __async(this, null, function* () {
      const billing = yield this.getBilling();
      return { pricingModel: billing.pricingModel };
    });
    /**
     * Get usage meter balances for the authenticated customer.
     *
     * By default, returns balances for all current subscriptions.
     * Optionally filter by a specific subscriptionId.
     *
     * @param params - Optional parameters for fetching usage balances
     * @param params.subscriptionId - Optional. Filter to a specific subscription.
     *
     * @returns A promise that resolves to an object containing usage meter balances
     *
     * @throws {Error} If the customer is not authenticated
     *
     * @example
     * // Get all usage meter balances for current subscriptions
     * const { usageMeterBalances } = await flowglad.getUsageMeterBalances()
     *
     * @example
     * // Get usage balances for a specific subscription
     * const { usageMeterBalances } = await flowglad.getUsageMeterBalances({
     *   subscriptionId: 'sub_123'
     * })
     */
    this.getUsageMeterBalances = (params) => __async(this, null, function* () {
      const customer = yield this.findOrCreateCustomer();
      return this.flowgladNode.get(
        `/api/v1/customers/${customer.externalId}/usage-balances`,
        {
          query: params != null ? params : {}
        }
      );
    });
    this.deriveSubscriptionId = (maybeSubscriptionId) => __async(this, null, function* () {
      var _a;
      if (maybeSubscriptionId) {
        return maybeSubscriptionId;
      }
      const billing = yield this.getBilling();
      const currentSubscriptions = (_a = billing.currentSubscriptions) != null ? _a : [];
      if (currentSubscriptions.length === 0) {
        throw new Error(
          "No active subscription found for this customer"
        );
      }
      if (currentSubscriptions.length > 1) {
        throw new Error(
          "Customer has multiple active subscriptions. Please specify subscriptionId."
        );
      }
      return currentSubscriptions[0].id;
    });
    /**
     * Get all resources and their usage for the customer's subscription.
     *
     * Returns capacity, claimed count, and available count for all resources
     * in the subscription's pricing model.
     *
     * @param params - Optional parameters for fetching resources
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     *
     * @returns A promise that resolves to an object containing an array of resources with usage data
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     *
     * @example
     * // Get all resources for the customer's subscription
     * const { resources } = await flowglad.getResourceUsages()
     * for (const resource of resources) {
     *   console.log(`${resource.resourceSlug}: ${resource.claimed}/${resource.capacity} used`)
     * }
     *
     * @example
     * // Get resources for a specific subscription
     * const { resources } = await flowglad.getResourceUsages({ subscriptionId: 'sub_123' })
     */
    this.getResourceUsages = (params) => __async(this, null, function* () {
      const subscriptionId = yield this.deriveSubscriptionId(
        params == null ? void 0 : params.subscriptionId
      );
      const { subscription } = yield this.flowgladNode.subscriptions.retrieve(subscriptionId);
      const { customer } = yield this.getCustomer();
      if (subscription.customerId !== customer.id) {
        throw new Error("Subscription is not owned by the current user");
      }
      const usages = yield this.flowgladNode.get(
        `/api/v1/resource-claims/${subscriptionId}/usages`
      );
      return {
        resources: usages.map((entry) => entry.usage)
      };
    });
    /**
     * Get usage for a single resource for the customer's subscription.
     *
     * Returns capacity, claimed count, available count, and active claims
     * for a specific resource identified by slug or ID.
     *
     * @param params - Parameters for fetching resource usage
     * @param params.resourceSlug - The slug identifying the resource type (e.g., 'seats', 'api_keys')
     * @param params.resourceId - Alternative to resourceSlug: The ID of the resource
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     *
     * @returns A promise that resolves to an object containing usage data and active claims
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     *
     * @example
     * // Get usage for seats resource by slug
     * const { usage, claims } = await flowglad.getResourceUsage({ resourceSlug: 'seats' })
     * console.log(`${usage.claimed}/${usage.capacity} seats used`)
     *
     * @example
     * // Get usage for a specific subscription
     * const { usage, claims } = await flowglad.getResourceUsage({
     *   resourceSlug: 'seats',
     *   subscriptionId: 'sub_123'
     * })
     */
    this.getResourceUsage = (params) => __async(this, null, function* () {
      const subscriptionId = yield this.deriveSubscriptionId(
        params == null ? void 0 : params.subscriptionId
      );
      const { subscription } = yield this.flowgladNode.subscriptions.retrieve(subscriptionId);
      const { customer } = yield this.getCustomer();
      if (subscription.customerId !== customer.id) {
        throw new Error("Subscription is not owned by the current user");
      }
      return yield this.flowgladNode.resourceClaims.retrieveUsage(
        subscriptionId,
        params
      );
    });
    /**
     * Claim resources from a subscription's capacity.
     *
     * Resources represent claimable capacity like seats, API keys, or other
     * countable entitlements. This method reserves capacity from the subscription's
     * available pool.
     *
     * ## Modes
     *
     * Choose ONE of the following modes per call:
     *
     * ### Anonymous Claims Mode
     * Use `quantity` to claim N anonymous resources. These are interchangeable
     * and released in FIFO order when releasing by quantity.
     *
     * ### Named Claims Mode
     * Use `externalId` or `externalIds` to claim resources with identifiers.
     * These are idempotent - claiming the same externalId twice returns the
     * existing claim without creating a duplicate.
     *
     * @param params - Parameters for claiming resources
     * @param params.resourceSlug - The slug identifying the resource type (e.g., 'seats', 'api_keys')
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     * @param params.quantity - Anonymous mode: Number of anonymous resources to claim
     * @param params.externalId - Named mode: Single identifier for a named resource
     * @param params.externalIds - Named mode: Array of identifiers for multiple named resources
     * @param params.metadata - Optional key-value data to attach to claims
     *
     * @returns A promise that resolves to an object containing the created claims and updated usage
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     * @throws {Error} If insufficient capacity is available to fulfill the claim
     *
     * @example
     * // Claim 3 anonymous seats (anonymous mode)
     * const result = await flowglad.claimResource({
     *   resourceSlug: 'seats',
     *   quantity: 3
     * })
     *
     * @example
     * // Claim a specific seat for a user (named mode, idempotent)
     * const result = await flowglad.claimResource({
     *   resourceSlug: 'seats',
     *   externalId: 'user_123',
     *   metadata: { assignedTo: 'John Doe' }
     * })
     *
     * @example
     * // Claim multiple named seats at once
     * const result = await flowglad.claimResource({
     *   resourceSlug: 'seats',
     *   externalIds: ['user_123', 'user_456', 'user_789']
     * })
     */
    this.claimResource = (params) => __async(this, null, function* () {
      var _a;
      let subscriptionId = params.subscriptionId;
      if (!subscriptionId) {
        const billing = yield this.getBilling();
        const currentSubscriptions = (_a = billing.currentSubscriptions) != null ? _a : [];
        if (currentSubscriptions.length === 0) {
          throw new Error(
            "No active subscription found for this customer"
          );
        }
        if (currentSubscriptions.length > 1) {
          throw new Error(
            "Customer has multiple active subscriptions. Please specify subscriptionId."
          );
        }
        subscriptionId = currentSubscriptions[0].id;
      }
      const { subscription } = yield this.flowgladNode.subscriptions.retrieve(subscriptionId);
      const { customer } = yield this.getCustomer();
      if (subscription.customerId !== customer.id) {
        throw new Error("Subscription is not owned by the current user");
      }
      return this.flowgladNode.resourceClaims.claim(subscriptionId, {
        resourceSlug: params.resourceSlug,
        metadata: params.metadata,
        quantity: params.quantity,
        externalId: params.externalId,
        externalIds: params.externalIds
      });
    });
    /**
     * Release claimed resources back to the subscription's available pool.
     *
     * ## Modes
     *
     * Choose ONE of the following modes per call:
     *
     * ### Anonymous Mode
     * Use `quantity` to release N anonymous claims in FIFO order (oldest first).
     *
     * ### Named Mode by External ID
     * Use `externalId` or `externalIds` to release specific named claims.
     *
     * ### Direct Mode
     * Use `claimIds` to release specific claims by their database IDs.
     *
     * @param params - Parameters for releasing resources
     * @param params.resourceSlug - The slug identifying the resource type
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     * @param params.quantity - Anonymous mode: Number of anonymous claims to release (FIFO)
     * @param params.externalId - Named mode: Single identifier to release
     * @param params.externalIds - Named mode: Array of identifiers to release
     * @param params.claimIds - Direct mode: Array of claim IDs to release
     *
     * @returns A promise that resolves to an object containing the released claims and updated usage
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     *
     * @example
     * // Release 2 anonymous seats (anonymous mode, FIFO)
     * const result = await flowglad.releaseResource({
     *   resourceSlug: 'seats',
     *   quantity: 2
     * })
     *
     * @example
     * // Release a specific user's seat (named mode)
     * const result = await flowglad.releaseResource({
     *   resourceSlug: 'seats',
     *   externalId: 'user_123'
     * })
     *
     * @example
     * // Release multiple users' seats at once
     * const result = await flowglad.releaseResource({
     *   resourceSlug: 'seats',
     *   externalIds: ['user_123', 'user_456']
     * })
     *
     * @example
     * // Release specific claims by their IDs
     * const result = await flowglad.releaseResource({
     *   resourceSlug: 'seats',
     *   claimIds: ['claim_abc', 'claim_def']
     * })
     */
    this.releaseResource = (params) => __async(this, null, function* () {
      var _a;
      let subscriptionId = params.subscriptionId;
      if (!subscriptionId) {
        const billing = yield this.getBilling();
        const currentSubscriptions = (_a = billing.currentSubscriptions) != null ? _a : [];
        if (currentSubscriptions.length === 0) {
          throw new Error(
            "No active subscription found for this customer"
          );
        }
        if (currentSubscriptions.length > 1) {
          throw new Error(
            "Customer has multiple active subscriptions. Please specify subscriptionId."
          );
        }
        subscriptionId = currentSubscriptions[0].id;
      }
      const { subscription } = yield this.flowgladNode.subscriptions.retrieve(subscriptionId);
      const { customer } = yield this.getCustomer();
      if (subscription.customerId !== customer.id) {
        throw new Error("Subscription is not owned by the current user");
      }
      return this.flowgladNode.resourceClaims.release(subscriptionId, {
        resourceSlug: params.resourceSlug,
        quantity: params.quantity,
        externalId: params.externalId,
        externalIds: params.externalIds,
        claimIds: params.claimIds
      });
    });
    /**
     * List active resource claims for a subscription.
     *
     * Returns all active (unreleased) claims for the customer's subscription.
     * Can optionally filter by resource type using the resourceSlug parameter.
     *
     * @param params - Optional parameters for listing claims
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     * @param params.resourceSlug - Optional. Filter to specific resource type.
     *
     * @returns A promise that resolves to an object containing an array of active claims
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     *
     * @example
     * // List all active claims for the subscription
     * const { claims } = await flowglad.listResourceClaims()
     * console.log(`Total active claims: ${claims.length}`)
     *
     * @example
     * // List only seat claims
     * const { claims } = await flowglad.listResourceClaims({ resourceSlug: 'seats' })
     * const namedSeats = claims.filter(c => c.externalId !== null)
     * console.log(`Named seats: ${namedSeats.length}`)
     *
     * @example
     * // List claims for a specific subscription
     * const { claims } = await flowglad.listResourceClaims({
     *   subscriptionId: 'sub_123',
     *   resourceSlug: 'api_keys'
     * })
     */
    this.listResourceClaims = (params) => __async(this, null, function* () {
      var _a;
      let subscriptionId = params == null ? void 0 : params.subscriptionId;
      if (!subscriptionId) {
        const billing = yield this.getBilling();
        const currentSubscriptions = (_a = billing.currentSubscriptions) != null ? _a : [];
        if (currentSubscriptions.length === 0) {
          throw new Error(
            "No active subscription found for this customer"
          );
        }
        if (currentSubscriptions.length > 1) {
          throw new Error(
            "Customer has multiple active subscriptions. Please specify subscriptionId."
          );
        }
        subscriptionId = currentSubscriptions[0].id;
      }
      const { subscription } = yield this.flowgladNode.subscriptions.retrieve(subscriptionId);
      const { customer } = yield this.getCustomer();
      if (subscription.customerId !== customer.id) {
        throw new Error("Subscription is not owned by the current user");
      }
      return this.flowgladNode.get(
        `/api/v1/resource-claims/${subscriptionId}/claims`,
        {
          query: (params == null ? void 0 : params.resourceSlug) ? { resourceSlug: params.resourceSlug } : void 0
        }
      );
    });
    /**
     * Archives a customer by setting archived=true and canceling all active subscriptions.
     *
     * This is a dedicated method for archiving customers because archiving is a significant
     * state change with cascade effects (subscription cancellation), not just a field update.
     *
     * Behavior:
     * - If customer is already archived, returns immediately (idempotent)
     * - Cancels all active subscriptions with reason 'customer_archived'
     * - Sets archived=true on the customer
     *
     * After archiving:
     * - The customer's externalId is freed for reuse by a new customer
     * - ExternalId lookups will not return this customer by default
     * - Operations that create records attached to this customer will be blocked
     *
     * @param externalId - The external ID of the customer to archive
     * @returns The archived customer record
     */
    this.archiveCustomer = (externalId) => __async(this, null, function* () {
      const result = yield this.flowgladNode.post(
        `/api/v1/customers/${encodeURIComponent(externalId)}/archive`,
        {
          body: {}
        }
      );
      return result.customer;
    });
    this.createHandlerParams = createHandlerParams;
    this.flowgladNode = new import_node.Flowglad({
      apiKey: createHandlerParams.apiKey,
      baseURL: createHandlerParams.baseURL
    });
    if ("customerExternalId" in createHandlerParams) {
      this.scopedParams = {
        customerExternalId: createHandlerParams.customerExternalId,
        getCustomerDetails: createHandlerParams.getCustomerDetails
      };
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FlowgladServer
});
//# sourceMappingURL=FlowgladServer.cjs.map