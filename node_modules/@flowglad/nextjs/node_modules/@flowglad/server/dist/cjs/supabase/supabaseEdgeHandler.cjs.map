{"version":3,"sources":["../../../src/supabase/supabaseEdgeHandler.ts"],"sourcesContent":["import type { HTTPMethod } from '@flowglad/shared'\nimport {\n  type RequestHandlerOptions,\n  requestHandler,\n} from '../requestHandler'\n\n/**\n * Options for creating a Supabase Edge Functions handler with scoped FlowgladServer instances.\n */\nexport interface SupabaseEdgeHandlerOptions\n  extends RequestHandlerOptions<Request> {\n  /**\n   * Optional base path for explicit path extraction.\n   * When provided, strips this prefix from the URL pathname before extracting the Flowglad action path.\n   * More reliable than auto-detection for custom domains, proxies, or non-standard setups.\n   * @example '/functions/v1/api-flowglad'\n   */\n  basePath?: string\n}\n\n/**\n * Extracts path segments from a pathname string.\n * @param pathname - The pathname to extract segments from\n * @returns An array of path segments\n */\nconst extractPath = (pathname: string): string[] => {\n  const trimmedPath = pathname.replace(/^\\/+|\\/+$/g, '')\n  return trimmedPath === '' ? [] : trimmedPath.split('/')\n}\n\n/**\n * Creates a Supabase Edge Functions handler for Flowglad API routes.\n *\n * This handler adapts the standard Web `Request` API (used by Deno and Supabase Edge Functions)\n * to the Flowglad request handler pattern.\n *\n * @param options - Configuration options including customer ID extraction and FlowgladServer factory\n * @returns A handler function that accepts a Request and returns a Promise<Response>\n *\n * @example\n * ```typescript\n * import { supabaseEdgeHandler } from '@flowglad/server/supabase'\n * import { FlowgladServer } from '@flowglad/server'\n *\n * const handler = supabaseEdgeHandler({\n *   basePath: '/functions/v1/api-flowglad',\n *   getCustomerExternalId: async (req) => {\n *     // Extract customer ID from request (e.g., from auth header)\n *     const authHeader = req.headers.get('Authorization')\n *     // ... validate and extract user ID\n *     return userId\n *   },\n *   flowglad: (customerExternalId) => new FlowgladServer({\n *     customerExternalId,\n *     getCustomerDetails: async (id) => ({\n *       name: 'Customer Name',\n *       email: 'customer@example.com',\n *     }),\n *   }),\n * })\n *\n * // In your Supabase Edge Function\n * Deno.serve(handler)\n * ```\n */\nexport const supabaseEdgeHandler = (\n  options: SupabaseEdgeHandlerOptions\n): ((req: Request) => Promise<Response>) => {\n  const handler = requestHandler(options)\n\n  return async (req: Request): Promise<Response> => {\n    // Parse URL - handle invalid URLs with a 400 response\n    let url: URL\n    try {\n      url = new URL(req.url)\n    } catch (err: unknown) {\n      // URL parsing is a pre-processing step that requestHandler doesn't handle,\n      // so we call onError here for this specific error type\n      if (options.onError) {\n        options.onError(err)\n      }\n      return new Response(\n        JSON.stringify({\n          data: null,\n          error: { message: 'Invalid request URL' },\n        }),\n        {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        }\n      )\n    }\n\n    // Extract path segments based on basePath or auto-detection\n    let pathSegments: string[] = []\n\n    if (options.basePath) {\n      // Explicit basePath provided - strip it from the pathname\n      const basePathTrimmed = options.basePath.replace(\n        /^\\/+|\\/+$/g,\n        ''\n      )\n      const basePathWithSlash = `/${basePathTrimmed}`\n\n      if (url.pathname.startsWith(basePathWithSlash)) {\n        const relativePath = url.pathname.slice(\n          basePathWithSlash.length\n        )\n        pathSegments = extractPath(relativePath)\n      } else {\n        // Cannot match basePath, fallback to using entire pathname\n        pathSegments = extractPath(url.pathname)\n      }\n    } else {\n      // Auto-detect: assume pattern /functions/v1/<function-name>/<rest>\n      const segments = extractPath(url.pathname)\n      if (\n        segments.length >= 3 &&\n        segments[0] === 'functions' &&\n        segments[1] === 'v1'\n      ) {\n        // Skip 'functions', 'v1', and function name (3 segments)\n        pathSegments = segments.slice(3)\n      } else {\n        // Fallback: treat entire pathname as path\n        pathSegments = segments\n      }\n    }\n\n    // Handle query params\n    const queryParams = Array.from(url.searchParams.entries())\n    const query =\n      queryParams.length > 0\n        ? Object.fromEntries(queryParams)\n        : undefined\n\n    // Handle body for non-GET requests\n    let body: unknown = undefined\n    if (req.method !== 'GET') {\n      try {\n        body = await req.json()\n      } catch {\n        // Body parsing failures are not errors - leave body undefined\n        // and let requestHandler validate the input\n      }\n    }\n\n    // Delegate to requestHandler - it handles its own errors internally\n    // and returns a RequestHandlerOutput with appropriate status codes.\n    // onError is called by requestHandler for errors during request processing.\n    // We wrap this in try-catch only to handle truly unexpected errors (e.g., if\n    // onError itself throws, which escapes requestHandler's error handling).\n    try {\n      const result = await handler(\n        {\n          path: pathSegments,\n          method: req.method as HTTPMethod,\n          query,\n          body,\n        },\n        req\n      )\n\n      return new Response(\n        JSON.stringify({\n          data: result.data ?? null,\n          error: result.error ?? null,\n        }),\n        {\n          status: result.status,\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        }\n      )\n    } catch (err: unknown) {\n      // This catch handles errors that escape requestHandler (e.g., onError throwing).\n      // We do NOT call onError here to avoid infinite loops if onError itself is the cause.\n      const errorMessage =\n        err instanceof Error ? err.message : 'Internal server error'\n\n      return new Response(\n        JSON.stringify({\n          data: null,\n          error: { message: errorMessage },\n        }),\n        {\n          status: 500,\n          headers: { 'Content-Type': 'application/json' },\n        }\n      )\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,4BAGO;AAqBP,MAAM,cAAc,CAAC,aAA+B;AAClD,QAAM,cAAc,SAAS,QAAQ,cAAc,EAAE;AACrD,SAAO,gBAAgB,KAAK,CAAC,IAAI,YAAY,MAAM,GAAG;AACxD;AAqCO,MAAM,sBAAsB,CACjC,YAC0C;AAC1C,QAAM,cAAU,sCAAe,OAAO;AAEtC,SAAO,CAAO,QAAoC;AAtEpD;AAwEI,QAAI;AACJ,QAAI;AACF,YAAM,IAAI,IAAI,IAAI,GAAG;AAAA,IACvB,SAAS,KAAc;AAGrB,UAAI,QAAQ,SAAS;AACnB,gBAAQ,QAAQ,GAAG;AAAA,MACrB;AACA,aAAO,IAAI;AAAA,QACT,KAAK,UAAU;AAAA,UACb,MAAM;AAAA,UACN,OAAO,EAAE,SAAS,sBAAsB;AAAA,QAC1C,CAAC;AAAA,QACD;AAAA,UACE,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAGA,QAAI,eAAyB,CAAC;AAE9B,QAAI,QAAQ,UAAU;AAEpB,YAAM,kBAAkB,QAAQ,SAAS;AAAA,QACvC;AAAA,QACA;AAAA,MACF;AACA,YAAM,oBAAoB,IAAI,eAAe;AAE7C,UAAI,IAAI,SAAS,WAAW,iBAAiB,GAAG;AAC9C,cAAM,eAAe,IAAI,SAAS;AAAA,UAChC,kBAAkB;AAAA,QACpB;AACA,uBAAe,YAAY,YAAY;AAAA,MACzC,OAAO;AAEL,uBAAe,YAAY,IAAI,QAAQ;AAAA,MACzC;AAAA,IACF,OAAO;AAEL,YAAM,WAAW,YAAY,IAAI,QAAQ;AACzC,UACE,SAAS,UAAU,KACnB,SAAS,CAAC,MAAM,eAChB,SAAS,CAAC,MAAM,MAChB;AAEA,uBAAe,SAAS,MAAM,CAAC;AAAA,MACjC,OAAO;AAEL,uBAAe;AAAA,MACjB;AAAA,IACF;AAGA,UAAM,cAAc,MAAM,KAAK,IAAI,aAAa,QAAQ,CAAC;AACzD,UAAM,QACJ,YAAY,SAAS,IACjB,OAAO,YAAY,WAAW,IAC9B;AAGN,QAAI,OAAgB;AACpB,QAAI,IAAI,WAAW,OAAO;AACxB,UAAI;AACF,eAAO,MAAM,IAAI,KAAK;AAAA,MACxB,SAAQ;AAAA,MAGR;AAAA,IACF;AAOA,QAAI;AACF,YAAM,SAAS,MAAM;AAAA,QACnB;AAAA,UACE,MAAM;AAAA,UACN,QAAQ,IAAI;AAAA,UACZ;AAAA,UACA;AAAA,QACF;AAAA,QACA;AAAA,MACF;AAEA,aAAO,IAAI;AAAA,QACT,KAAK,UAAU;AAAA,UACb,OAAM,YAAO,SAAP,YAAe;AAAA,UACrB,QAAO,YAAO,UAAP,YAAgB;AAAA,QACzB,CAAC;AAAA,QACD;AAAA,UACE,QAAQ,OAAO;AAAA,UACf,SAAS;AAAA,YACP,gBAAgB;AAAA,UAClB;AAAA,QACF;AAAA,MACF;AAAA,IACF,SAAS,KAAc;AAGrB,YAAM,eACJ,eAAe,QAAQ,IAAI,UAAU;AAEvC,aAAO,IAAI;AAAA,QACT,KAAK,UAAU;AAAA,UACb,MAAM;AAAA,UACN,OAAO,EAAE,SAAS,aAAa;AAAA,QACjC,CAAC;AAAA,QACD;AAAA,UACE,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;","names":[]}