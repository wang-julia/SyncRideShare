"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var endpoints_exports = {};
__export(endpoints_exports, {
  createBillingEndpoints: () => createBillingEndpoints,
  createGetCustomerDetails: () => createGetCustomerDetails,
  createGetExternalIdEndpoint: () => createGetExternalIdEndpoint,
  createGetPricingModelEndpoint: () => createGetPricingModelEndpoint,
  getCreatorRoleFromOrgOptions: () => getCreatorRoleFromOrgOptions,
  getOrgOptionsFromCtxContext: () => getOrgOptionsFromCtxContext,
  getOrganizationDetails: () => getOrganizationDetails,
  getStringProp: () => getStringProp,
  isAdapterLike: () => isAdapterLike,
  isRecord: () => isRecord,
  resolveCustomerExternalId: () => resolveCustomerExternalId
});
module.exports = __toCommonJS(endpoints_exports);
var import_shared = require("@flowglad/shared");
var import_api = require("better-auth/api");
var import_plugins = require("better-auth/plugins");
var import_zod = require("zod");
var import_FlowgladServer = require('../FlowgladServer.cjs');
var import_FlowgladServerAdmin = require('../FlowgladServerAdmin.cjs');
var import_subrouteHandlers = require('../subrouteHandlers/index.cjs');
var import_pricingModelHandlers = require('../subrouteHandlers/pricingModelHandlers.cjs');
const isRecord = (value) => {
  return typeof value === "object" && value !== null && !Array.isArray(value);
};
const getStringProp = (record, key) => {
  const value = record[key];
  if (typeof value !== "string") {
    return null;
  }
  return value;
};
const isAdapterLike = (value) => {
  if (!isRecord(value)) {
    return false;
  }
  return typeof value.findOne === "function" && typeof value.findMany === "function";
};
const getOrgOptionsFromCtxContext = (ctxContext) => {
  if (!isRecord(ctxContext)) {
    return void 0;
  }
  const orgOptions = ctxContext.orgOptions;
  if (!isRecord(orgOptions)) {
    return void 0;
  }
  return orgOptions;
};
const getCreatorRoleFromOrgOptions = (orgOptions) => {
  if (!orgOptions) {
    return void 0;
  }
  const creatorRole = orgOptions.creatorRole;
  return typeof creatorRole === "string" ? creatorRole : void 0;
};
const getOrganizationDetails = (params) => __async(null, null, function* () {
  var _a, _b, _c, _d, _e, _f;
  const creatorRole = (_a = params.creatorRole) != null ? _a : "owner";
  const [memberResult, organizationResult, ownerMembersResult] = yield Promise.all([
    params.adapter.findOne({
      model: "member",
      where: [
        { field: "userId", value: params.userId },
        { field: "organizationId", value: params.organizationId }
      ]
    }),
    params.adapter.findOne({
      model: "organization",
      where: [{ field: "id", value: params.organizationId }]
    }),
    params.adapter.findMany({
      model: "member",
      where: [
        { field: "organizationId", value: params.organizationId },
        { field: "role", value: creatorRole }
      ]
    })
  ]);
  if (!isRecord(memberResult)) {
    return null;
  }
  const memberRole = getStringProp(memberResult, "role");
  const memberUserId = (_b = getStringProp(memberResult, "userId")) != null ? _b : params.userId;
  let ownerUserId = memberRole === creatorRole ? memberUserId : null;
  if (!ownerUserId && Array.isArray(ownerMembersResult)) {
    const firstOwner = (_c = ownerMembersResult.find(isRecord)) != null ? _c : null;
    ownerUserId = firstOwner ? getStringProp(firstOwner, "userId") : null;
  }
  const ownerUserResult = ownerUserId ? yield params.adapter.findOne({
    model: "user",
    where: [{ field: "id", value: ownerUserId }]
  }) : null;
  const organizationName = isRecord(organizationResult) ? (_e = (_d = getStringProp(organizationResult, "name")) != null ? _d : getStringProp(organizationResult, "slug")) != null ? _e : "Organization" : "Organization";
  const ownerEmail = isRecord(ownerUserResult) ? (_f = getStringProp(ownerUserResult, "email")) != null ? _f : "" : "";
  return {
    id: params.organizationId,
    name: organizationName,
    email: ownerEmail
  };
});
const createGetCustomerDetails = (params) => {
  return () => __async(null, null, function* () {
    var _a;
    const organizationId = params.options.customerType === "organization" ? (_a = params.session.session.activeOrganizationId) != null ? _a : null : null;
    const innerSession = {
      user: {
        id: params.session.user.id,
        name: params.session.user.name || "",
        email: params.session.user.email || "",
        organizationId
      }
    };
    if (params.options.getCustomer) {
      const customerInfo = yield params.options.getCustomer(innerSession);
      return { name: customerInfo.name, email: customerInfo.email };
    }
    if (params.options.customerType === "organization" && params.session.session.activeOrganizationId && isAdapterLike(params.adapter)) {
      const creatorRole = getCreatorRoleFromOrgOptions(
        getOrgOptionsFromCtxContext(params.ctxContext)
      );
      const org = yield getOrganizationDetails({
        adapter: params.adapter,
        organizationId: params.session.session.activeOrganizationId,
        userId: params.session.user.id,
        creatorRole
      });
      if (org) {
        return { name: org.name, email: org.email };
      }
    }
    return {
      name: params.session.user.name || "",
      email: params.session.user.email || ""
    };
  });
};
const resolveCustomerExternalId = (options, session) => {
  if (options.customerType === "organization") {
    if (!session.session.activeOrganizationId) {
      return {
        error: {
          code: "NO_ACTIVE_ORGANIZATION",
          message: "Organization billing requires an active organization. Please select or create an organization first."
        }
      };
    }
    return { externalId: session.session.activeOrganizationId };
  }
  return { externalId: session.session.userId };
};
const createGetExternalIdEndpoint = (options) => {
  return (0, import_plugins.createAuthEndpoint)(
    "/flowglad/get-external-id",
    {
      method: "GET",
      metadata: {
        isAction: true
      }
    },
    (ctx) => __async(null, null, function* () {
      if (!ctx.headers || !ctx.headers.get) {
        throw new Error(
          "Flowglad Better Auth Plugin: Headers are required for getExternalId().\nUsage: await auth.api.getExternalId({ headers: await headers() })"
        );
      }
      const session = yield (0, import_api.getSessionFromCtx)(ctx);
      if (!session) {
        return ctx.json({
          externalId: null
        });
      }
      const organizationId = session.session.activeOrganizationId;
      if (options.customerType === "organization") {
        return ctx.json({
          externalId: organizationId != null ? organizationId : null
        });
      }
      return ctx.json({
        externalId: session.session.userId
      });
    })
  );
};
const createFlowgladBillingEndpoint = (params) => {
  return (0, import_plugins.createAuthEndpoint)(
    `/flowglad/${params.actionKey}`,
    {
      method: "POST",
      // Use a permissive schema so Better Call parses the JSON body for us
      // Handlers will do their own validation
      body: import_zod.z.record(import_zod.z.string(), import_zod.z.any()),
      metadata: {
        isAction: true
      }
    },
    (ctx) => __async(null, null, function* () {
      var _a;
      const sessionResult = yield (0, import_api.getSessionFromCtx)(ctx);
      if (!sessionResult) {
        return ctx.json(
          {
            error: {
              code: "UNAUTHORIZED",
              message: "Authentication required"
            }
          },
          { status: 401 }
        );
      }
      const session = sessionResult;
      const getCustomerDetailsForSession = createGetCustomerDetails({
        options: params.options,
        session,
        ctxContext: ctx.context,
        adapter: ctx.context.adapter
      });
      const customerResult = resolveCustomerExternalId(
        params.options,
        session
      );
      if ("error" in customerResult) {
        return ctx.json(
          { error: customerResult.error },
          { status: 400 }
        );
      }
      if (params.options.customerType === "organization" && isAdapterLike(ctx.context.adapter)) {
        const membership = yield ctx.context.adapter.findOne({
          model: "member",
          where: [
            { field: "userId", value: session.user.id },
            {
              field: "organizationId",
              value: customerResult.externalId
            }
          ]
        });
        if (!isRecord(membership)) {
          return ctx.json(
            {
              error: {
                code: "NOT_ORGANIZATION_MEMBER",
                message: "You are not a member of this organization"
              }
            },
            { status: 403 }
          );
        }
      }
      const rawBody = isRecord(ctx.body) ? ctx.body : {};
      const shouldInjectCustomerExternalIdIntoBody = params.actionKey === import_shared.FlowgladActionKey.GetCustomerBilling || params.actionKey === import_shared.FlowgladActionKey.FindOrCreateCustomer || params.actionKey === import_shared.FlowgladActionKey.UpdateCustomer;
      const bodyForValidation = shouldInjectCustomerExternalIdIntoBody ? __spreadProps(__spreadValues({}, rawBody), {
        externalId: customerResult.externalId
      }) : rawBody;
      const validatedBody = params.validator.inputValidator.safeParse(bodyForValidation);
      if (!validatedBody.success) {
        return ctx.json(
          {
            error: {
              code: "VALIDATION_ERROR",
              message: "Invalid request body",
              details: validatedBody.error.flatten()
            }
          },
          { status: 400 }
        );
      }
      const apiKey = params.options.apiKey || process.env.FLOWGLAD_SECRET_KEY;
      const flowgladServerConfig = {
        customerExternalId: customerResult.externalId,
        getCustomerDetails: getCustomerDetailsForSession
      };
      if (apiKey) {
        flowgladServerConfig.apiKey = apiKey;
      }
      if (params.options.baseURL) {
        flowgladServerConfig.baseURL = params.options.baseURL;
      }
      const flowgladServer = new import_FlowgladServer.FlowgladServer(flowgladServerConfig);
      const result = yield params.handler(
        {
          method: params.validator.method,
          data: validatedBody.data
        },
        flowgladServer
      );
      if (result.error) {
        return ctx.json(
          {
            error: {
              code: result.error.code,
              message: typeof ((_a = result.error.json) == null ? void 0 : _a.message) === "string" ? result.error.json.message : `Flowglad API error: ${result.error.code}`,
              details: result.error.json
            }
          },
          { status: result.status }
        );
      }
      return ctx.json(
        { data: result.data },
        { status: result.status }
      );
    })
  );
};
const createGetPricingModelEndpoint = (options) => {
  return (0, import_plugins.createAuthEndpoint)(
    "/flowglad/pricing-models/retrieve",
    {
      method: "POST",
      metadata: {
        isAction: true
      }
    },
    (ctx) => __async(null, null, function* () {
      const apiKey = options.apiKey || process.env.FLOWGLAD_SECRET_KEY;
      if (!apiKey) {
        return ctx.json(
          {
            error: {
              code: "CONFIGURATION_ERROR",
              message: "API key required. Provide apiKey option or set FLOWGLAD_SECRET_KEY."
            }
          },
          { status: 500 }
        );
      }
      const flowgladServerAdmin = new import_FlowgladServerAdmin.FlowgladServerAdmin({
        apiKey,
        baseURL: options.baseURL
      });
      let flowgladServer = null;
      const sessionResult = yield (0, import_api.getSessionFromCtx)(ctx);
      if (sessionResult) {
        const session = sessionResult;
        const customerResult = resolveCustomerExternalId(
          options,
          session
        );
        if (!("error" in customerResult)) {
          const getCustomerDetailsForSession = createGetCustomerDetails({
            options,
            session,
            ctxContext: ctx.context,
            adapter: ctx.context.adapter
          });
          const flowgladServerConfig = {
            customerExternalId: customerResult.externalId,
            getCustomerDetails: getCustomerDetailsForSession
          };
          if (apiKey) {
            flowgladServerConfig.apiKey = apiKey;
          }
          if (options.baseURL) {
            flowgladServerConfig.baseURL = options.baseURL;
          }
          flowgladServer = new import_FlowgladServer.FlowgladServer(flowgladServerConfig);
        }
      }
      const result = yield (0, import_pricingModelHandlers.getPricingModel)(
        { method: import_shared.HTTPMethod.POST, data: {} },
        { flowgladServer, flowgladServerAdmin }
      );
      if (result.error) {
        const errorJson = result.error.json;
        const message = typeof (errorJson == null ? void 0 : errorJson.message) === "string" ? errorJson.message : void 0;
        const details = typeof (errorJson == null ? void 0 : errorJson.details) === "string" ? errorJson.details : void 0;
        return ctx.json(
          {
            error: {
              code: result.error.code,
              message,
              details
            }
          },
          { status: result.status }
        );
      }
      return ctx.json({ data: result.data });
    })
  );
};
const createBillingEndpoints = (options) => {
  return {
    getCustomerBilling: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.GetCustomerBilling,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.GetCustomerBilling],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.GetCustomerBilling],
      options
    }),
    findOrCreateCustomer: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.FindOrCreateCustomer,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.FindOrCreateCustomer],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.FindOrCreateCustomer],
      options
    }),
    createCheckoutSession: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.CreateCheckoutSession,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.CreateCheckoutSession],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.CreateCheckoutSession],
      options
    }),
    createAddPaymentMethodCheckoutSession: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.CreateAddPaymentMethodCheckoutSession,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.CreateAddPaymentMethodCheckoutSession],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.CreateAddPaymentMethodCheckoutSession],
      options
    }),
    createActivateSubscriptionCheckoutSession: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.CreateActivateSubscriptionCheckoutSession,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.CreateActivateSubscriptionCheckoutSession],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.CreateActivateSubscriptionCheckoutSession],
      options
    }),
    cancelSubscription: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.CancelSubscription,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.CancelSubscription],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.CancelSubscription],
      options
    }),
    uncancelSubscription: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.UncancelSubscription,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.UncancelSubscription],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.UncancelSubscription],
      options
    }),
    adjustSubscription: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.AdjustSubscription,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.AdjustSubscription],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.AdjustSubscription],
      options
    }),
    createSubscription: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.CreateSubscription,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.CreateSubscription],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.CreateSubscription],
      options
    }),
    updateCustomer: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.UpdateCustomer,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.UpdateCustomer],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.UpdateCustomer],
      options
    }),
    createUsageEvent: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.CreateUsageEvent,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.CreateUsageEvent],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.CreateUsageEvent],
      options
    }),
    // Resource claim endpoints
    getResources: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.GetResourceUsages,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.GetResourceUsages],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.GetResourceUsages],
      options
    }),
    getResourceUsage: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.GetResourceUsage,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.GetResourceUsage],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.GetResourceUsage],
      options
    }),
    claimResource: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.ClaimResource,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.ClaimResource],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.ClaimResource],
      options
    }),
    releaseResource: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.ReleaseResource,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.ReleaseResource],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.ReleaseResource],
      options
    }),
    listResourceClaims: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.ListResourceClaims,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.ListResourceClaims],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.ListResourceClaims],
      options
    }),
    // Usage meter endpoints
    getUsageMeterBalances: createFlowgladBillingEndpoint({
      actionKey: import_shared.FlowgladActionKey.GetUsageMeterBalances,
      validator: import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.GetUsageMeterBalances],
      handler: import_subrouteHandlers.routeToHandlerMap[import_shared.FlowgladActionKey.GetUsageMeterBalances],
      options
    })
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createBillingEndpoints,
  createGetCustomerDetails,
  createGetExternalIdEndpoint,
  createGetPricingModelEndpoint,
  getCreatorRoleFromOrgOptions,
  getOrgOptionsFromCtxContext,
  getOrganizationDetails,
  getStringProp,
  isAdapterLike,
  isRecord,
  resolveCustomerExternalId
});
//# sourceMappingURL=endpoints.cjs.map