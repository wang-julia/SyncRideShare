{"version":3,"sources":["../../../src/subrouteHandlers/test-utils.ts"],"sourcesContent":["import { expect } from 'vitest'\n\n/**\n * The response shape returned by all subroute handlers.\n */\ntype HandlerResponse = {\n  status: number\n  error?: {\n    code: string\n    json: Record<string, unknown>\n  }\n  data: Record<string, unknown>\n}\n\n/**\n * Expected response configuration for assertHandlerResponse.\n *\n * - status: Required HTTP status code\n * - error: Either 'undefined' (success case), or an object with:\n *   - code: The expected error code string\n *   - json: Expected json object OR a matcher function for flexible assertions\n * - data: Expected data object OR a matcher function\n */\ntype ExpectedResponse = {\n  status: number\n  error?:\n    | 'undefined'\n    | {\n        code: string\n        json?:\n          | Record<string, unknown>\n          | ((json: Record<string, unknown>) => void)\n      }\n  data?:\n    | Record<string, unknown>\n    | ((data: Record<string, unknown>) => void)\n}\n\n/**\n * Core assertion helper that validates handler response against expected shape.\n */\nexport const assertHandlerResponse = (\n  actual: HandlerResponse,\n  expected: ExpectedResponse\n): void => {\n  expect(actual.status).toBe(expected.status)\n\n  if (expected.error === 'undefined') {\n    expect(actual.error).toBeUndefined()\n  } else if (expected.error !== undefined) {\n    expect(actual.error).not.toBeUndefined()\n    expect(actual.error!.code).toBe(expected.error.code)\n\n    if (expected.error.json !== undefined) {\n      if (typeof expected.error.json === 'function') {\n        expected.error.json(actual.error!.json)\n      } else {\n        expect(actual.error!.json).toEqual(expected.error.json)\n      }\n    }\n  }\n\n  if (expected.data !== undefined) {\n    if (typeof expected.data === 'function') {\n      expected.data(actual.data)\n    } else {\n      expect(actual.data).toEqual(expected.data)\n    }\n  }\n}\n\n// ============================================================================\n// PRESETS: Higher-order functions that return configured assertion calls\n// ============================================================================\n\n/**\n * Preset for 405 Method Not Allowed responses.\n *\n * Handles both error formats found in the codebase:\n * - 'standard': { code: 'Method not allowed', json: {} }\n * - 'numbered': { code: '405', json: { message: 'Method not allowed' } }\n */\nexport const assert405MethodNotAllowed = (\n  actual: HandlerResponse,\n  variant: 'standard' | 'numbered' = 'standard'\n) => {\n  assertHandlerResponse(actual, {\n    status: 405,\n    error:\n      variant === 'standard'\n        ? { code: 'Method not allowed', json: {} }\n        : { code: '405', json: { message: 'Method not allowed' } },\n    data: {},\n  })\n}\n\n/**\n * Preset for 200 success responses.\n */\nexport const assert200Success = <T extends Record<string, unknown>>(\n  actual: HandlerResponse,\n  expectedData: T\n) => {\n  assertHandlerResponse(actual, {\n    status: 200,\n    error: 'undefined',\n    data: expectedData,\n  })\n}\n\n/**\n * Preset for 500 error responses with handler-specific error codes.\n */\nexport const assert500Error = (\n  actual: HandlerResponse,\n  errorCode: string,\n  message: string\n) => {\n  assertHandlerResponse(actual, {\n    status: 500,\n    error: {\n      code: errorCode,\n      json: { message },\n    },\n    data: {},\n  })\n}\n\n/**\n * Preset for 401 Unauthorized responses.\n */\nexport const assert401Unauthorized = (actual: HandlerResponse) => {\n  assertHandlerResponse(actual, {\n    status: 401,\n    error: {\n      code: '401',\n      json: { message: 'Unauthorized' },\n    },\n    data: {},\n  })\n}\n\n/**\n * Preset for 403 Forbidden responses with custom message.\n */\nexport const assert403Forbidden = (\n  actual: HandlerResponse,\n  message: string\n) => {\n  assertHandlerResponse(actual, {\n    status: 403,\n    error: {\n      code: 'forbidden',\n      json: { message },\n    },\n    data: {},\n  })\n}\n\n/**\n * Preset for 404 Not Found responses with custom message.\n */\nexport const assert404NotFound = (\n  actual: HandlerResponse,\n  message: string\n) => {\n  assertHandlerResponse(actual, {\n    status: 404,\n    error: {\n      code: '404',\n      json: { message },\n    },\n    data: {},\n  })\n}\n\n/**\n * Preset for 400 Bad Request responses with custom code and message.\n */\nexport const assert400BadRequest = (\n  actual: HandlerResponse,\n  errorCode: string,\n  message: string\n) => {\n  assertHandlerResponse(actual, {\n    status: 400,\n    error: {\n      code: errorCode,\n      json: { message },\n    },\n    data: {},\n  })\n}\n\n// ============================================================================\n// MATCHER HELPERS: For flexible assertions on error.json or data\n// ============================================================================\n\n/**\n * Creates a matcher that checks if message contains a substring.\n */\nexport const jsonMessageContains = (substring: string) => {\n  return (json: Record<string, unknown>) => {\n    expect(json.message).not.toBeUndefined()\n    expect(String(json.message)).toContain(substring)\n  }\n}\n\n/**\n * Creates a matcher that checks if message matches a regex.\n */\nexport const jsonMessageMatches = (pattern: RegExp) => {\n  return (json: Record<string, unknown>) => {\n    expect(json.message).not.toBeUndefined()\n    expect(String(json.message)).toMatch(pattern)\n  }\n}\n"],"mappings":"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","names":[]}