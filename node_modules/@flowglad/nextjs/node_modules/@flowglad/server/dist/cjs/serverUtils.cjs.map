{"version":3,"sources":["../../src/serverUtils.ts"],"sourcesContent":["import { z } from 'zod'\nimport type {\n  BetterAuthFlowgladServerSessionParams,\n  ClerkFlowgladServerSessionParams,\n  CoreCustomerUser,\n  FlowgladServerSessionParams,\n  NextjsAuthFlowgladServerSessionParams,\n  SupabaseFlowgladServerSessionParams,\n} from './types'\n\nexport const getSessionFromNextAuth = async (\n  params: NextjsAuthFlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const session = await params.nextAuth.auth()\n  if (session?.user) {\n    if (params.nextAuth.customerFromAuth) {\n      coreCustomerUser =\n        await params.nextAuth.customerFromAuth(session)\n    } else {\n      if (!session.user.email) {\n        throw new Error(\n          'FlowgladError: NextAuth session has no email. Please provide an extractUserIdFromSession function to extract the userId from the session, or include email on your sessions.'\n        )\n      }\n      coreCustomerUser = {\n        externalId: session.user.email,\n        name: session.user.name || '',\n        email: session.user.email || '',\n      }\n    }\n  }\n  return coreCustomerUser\n}\n\nconst getSessionFromNextAuth4 = async (\n  params: NextjsAuthFlowgladServerSessionParams\n) => {\n  const session = await params.nextAuth.auth()\n  return session\n}\n\nexport const sessionFromSupabaseAuth = async (\n  params: SupabaseFlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const {\n    data: { user },\n  } = await (await params.supabaseAuth.client()).auth.getUser()\n  if (user) {\n    coreCustomerUser = {\n      externalId: user.id,\n      name: user.user_metadata.name || '',\n      email: user.email || '',\n    }\n  }\n  return coreCustomerUser\n}\n\nexport const sessionFromClerkAuth = async (\n  params: ClerkFlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const session = await params.clerk.currentUser()\n  if (params.clerk.customerFromCurrentUser && session) {\n    coreCustomerUser =\n      await params.clerk.customerFromCurrentUser(session)\n  } else if (session) {\n    coreCustomerUser = {\n      externalId: session.id,\n      name: session.firstName || '',\n      email: session.emailAddresses[0].emailAddress || '',\n    }\n  }\n  return coreCustomerUser\n}\n\nexport const sessionFromBetterAuth = async (\n  params: BetterAuthFlowgladServerSessionParams\n) => {\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const session = await params.betterAuth.getSession()\n  if (session?.user) {\n    if (params.betterAuth.customerFromSession) {\n      coreCustomerUser =\n        await params.betterAuth.customerFromSession(session)\n    } else {\n      coreCustomerUser = {\n        externalId: session.user.id,\n        name: session.user.name || '',\n        email: session.user.email || '',\n      }\n    }\n  }\n  return coreCustomerUser\n}\n\nexport const getSessionFromParams = async (\n  params: FlowgladServerSessionParams,\n  scopedCustomerExternalId?: string\n) => {\n  // Short-circuit for scoped variant\n  if (scopedCustomerExternalId !== undefined) {\n    // Check if any other auth provider is also present\n    const hasOtherAuth =\n      'nextAuth' in params ||\n      'supabaseAuth' in params ||\n      'clerk' in params ||\n      'betterAuth' in params ||\n      ('getRequestingCustomer' in params &&\n        params.getRequestingCustomer)\n    if (hasOtherAuth) {\n      throw new Error(\n        'FlowgladError: customerExternalId cannot be used with other authentication methods.'\n      )\n    }\n\n    if (!scopedCustomerExternalId.trim()) {\n      throw new Error(\n        'FlowgladError: customerExternalId cannot be empty'\n      )\n    }\n    // For scoped variant, we bypass all auth logic and return a minimal customer object\n    // The actual customer data will be fetched from the API when needed\n    return {\n      externalId: scopedCustomerExternalId,\n      name: '',\n      email: '',\n    } as CoreCustomerUser\n  }\n\n  let coreCustomerUser: CoreCustomerUser | null = null\n  const providerCount = [\n    'nextAuth' in params,\n    'supabaseAuth' in params,\n    'clerk' in params,\n    'betterAuth' in params,\n  ].filter(Boolean).length\n  if (providerCount > 1) {\n    throw new Error(\n      'FlowgladError: Only one of nextAuth, supabaseAuth, clerk, or betterAuth may be defined at a time.'\n    )\n  }\n  if (\n    'getRequestingCustomer' in params &&\n    params.getRequestingCustomer\n  ) {\n    coreCustomerUser = await params.getRequestingCustomer()\n  } else {\n    if ('nextAuth' in params) {\n      coreCustomerUser = await getSessionFromNextAuth(params)\n    } else if ('supabaseAuth' in params) {\n      coreCustomerUser = await sessionFromSupabaseAuth(params)\n    } else if ('clerk' in params) {\n      coreCustomerUser = await sessionFromClerkAuth(params)\n    } else if ('betterAuth' in params) {\n      coreCustomerUser = await sessionFromBetterAuth(params)\n    }\n  }\n\n  const customerSchema = z.object({\n    externalId: z.string().min(1),\n    name: z.string(),\n    email: z.email(),\n  })\n  const parsedCustomer = customerSchema.safeParse(coreCustomerUser)\n  if (!parsedCustomer.success) {\n    throw new Error(\n      \"Unable to derive requesting customer from session. Please check your flowgladServer constructor, in your server's flowglad.ts file. This is an issue with how your user's session data on the server is being mapped to Flowglad requesting customer input.\\n\\n\" +\n        'Issues:\\n' +\n        `${parsedCustomer.error.issues.map((issue) => `- ${issue.path}: ${issue.message}`).join(`\\n`)}.\\n\\n` +\n        'Received input:\\n' +\n        JSON.stringify(coreCustomerUser)\n    )\n  }\n  return parsedCustomer.data\n}\n\nexport const parseErrorStringToErrorObject = (\n  errorString: string\n) => {\n  let [errorCode, ...errorJsonParts] = errorString.split(' ')\n  if (isNaN(Number(errorCode))) {\n    errorCode = 'Unknown'\n  }\n  let errorJson: Record<string, unknown> = {}\n  try {\n    errorJson = JSON.parse(errorJsonParts.join(' '))\n  } catch (e) {\n    errorJson = {\n      message: errorString,\n    }\n  }\n  return {\n    code: errorCode,\n    json: errorJson,\n  }\n}\n"],"mappings":"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","names":[]}