import { Flowglad as FlowgladNode } from '@flowglad/node';
import { type AdjustSubscriptionParams, type BillingWithChecks, type BulkCreateUsageEventsParams, type CancelSubscriptionParams, type ClaimResourceParams, type CreateActivateSubscriptionCheckoutSessionParams, type CreateAddPaymentMethodCheckoutSessionParams, type CreateProductCheckoutSessionParams, type CreateSubscriptionParams, type CreateUsageEventParams, type GetUsageMeterBalancesParams, type GetUsageMeterBalancesResponse, type ListResourceClaimsParams, type ReleaseResourceParams, type ResourceClaim, type ResourceIdentifier, type ResourceUsage, type UncancelSubscriptionParams } from '@flowglad/shared';
import type { CoreCustomerUser, FlowgladServerSessionParams } from './types';
export declare class FlowgladServer {
    private createHandlerParams;
    private flowgladNode;
    private scopedParams?;
    constructor(createHandlerParams: FlowgladServerSessionParams);
    getRequestingCustomerId: () => Promise<string>;
    getSession: () => Promise<CoreCustomerUser | null>;
    getBilling: () => Promise<BillingWithChecks>;
    findOrCreateCustomer: () => Promise<FlowgladNode.Customers.CustomerRetrieveResponse["customer"]>;
    getCustomer: () => Promise<FlowgladNode.Customers.CustomerRetrieveResponse>;
    createCustomer: (params: FlowgladNode.Customers.CustomerCreateParams) => Promise<FlowgladNode.Customers.CustomerCreateResponse>;
    /**
     * Create a checkout session.
     * You can provide either `priceId` or `priceSlug` (but not both).
     * @param params - Checkout session parameters. Must include either `priceId` or `priceSlug`, plus `successUrl` and `cancelUrl`.
     * @returns The created checkout session with a URL for redirecting the customer.
     */
    createCheckoutSession: (params: CreateProductCheckoutSessionParams) => Promise<FlowgladNode.CheckoutSessions.CheckoutSessionCreateResponse>;
    updateCustomer: (params: FlowgladNode.Customers.CustomerUpdateParams) => Promise<FlowgladNode.Customers.CustomerUpdateResponse>;
    createAddPaymentMethodCheckoutSession: (params: CreateAddPaymentMethodCheckoutSessionParams) => Promise<FlowgladNode.CheckoutSessions.CheckoutSessionCreateResponse>;
    createActivateSubscriptionCheckoutSession: (params: CreateActivateSubscriptionCheckoutSessionParams) => Promise<FlowgladNode.CheckoutSessions.CheckoutSessionCreateResponse>;
    cancelSubscription: (params: CancelSubscriptionParams) => Promise<FlowgladNode.Subscriptions.SubscriptionCancelResponse>;
    /**
     * Uncancel a subscription that is scheduled for cancellation.
     *
     * @param params - Parameters containing the subscription ID to uncancel
     * @returns The uncanceled subscription
     * @throws {Error} If the subscription is not owned by the authenticated customer
     *
     * Note: This method is idempotent. If the subscription is not in 'cancellation_scheduled'
     * status, it returns the subscription without modification.
     */
    uncancelSubscription: (params: UncancelSubscriptionParams) => Promise<FlowgladNode.Subscriptions.SubscriptionUncancelResponse>;
    /**
     * Adjust a subscription to a different price.
     *
     * @example
     * // Simplest: adjust by price slug (quantity defaults to 1)
     * await flowglad.adjustSubscription({ priceSlug: 'pro-monthly' })
     *
     * // With quantity
     * await flowglad.adjustSubscription({ priceSlug: 'pro-monthly', quantity: 5 })
     *
     * // Using price ID
     * await flowglad.adjustSubscription({ priceId: 'price_abc123', quantity: 3 })
     *
     * // With timing override
     * await flowglad.adjustSubscription({
     *   priceSlug: 'pro-monthly',
     *   timing: 'at_end_of_current_billing_period'
     * })
     *
     * // Explicit subscription ID (for multi-subscription customers)
     * await flowglad.adjustSubscription({
     *   priceSlug: 'pro-monthly',
     *   subscriptionId: 'sub_123'
     * })
     *
     * // Complex adjustment with multiple items
     * await flowglad.adjustSubscription({
     *   subscriptionItems: [
     *     { priceSlug: 'base-plan', quantity: 1 },
     *     { priceSlug: 'addon-storage', quantity: 3 },
     *   ],
     *   timing: 'immediately',
     *   prorate: true,
     * })
     *
     * @param params - Adjustment parameters (one of three forms)
     * @param params.priceSlug - Adjust to a price by slug (mutually exclusive with priceId and subscriptionItems)
     * @param params.priceId - Adjust to a price by ID (mutually exclusive with priceSlug and subscriptionItems)
     * @param params.subscriptionItems - Array of items for multi-item adjustments (mutually exclusive with priceSlug and priceId)
     * @param params.quantity - Number of units for single-price adjustments (default: 1)
     * @param params.subscriptionId - Subscription ID (auto-resolves if customer has exactly 1 subscription)
     * @param params.timing - 'immediately' | 'at_end_of_current_billing_period' | 'auto' (default: 'auto')
     *   - 'auto': Upgrades happen immediately, downgrades at end of period
     *   - 'immediately': Apply change now with proration
     *   - 'at_end_of_current_billing_period': Apply change at next billing period
     * @param params.prorate - Whether to prorate (default: true for immediate, false for end-of-period)
     * @returns The adjusted subscription and its items
     * @throws {Error} If customer has no active subscriptions
     * @throws {Error} If customer has multiple subscriptions and subscriptionId not provided
     * @throws {Error} If the subscription is not owned by the authenticated customer
     */
    adjustSubscription: (params: AdjustSubscriptionParams) => Promise<FlowgladNode.Subscriptions.SubscriptionAdjustResponse>;
    createSubscription: (params: Omit<CreateSubscriptionParams, "customerId">) => Promise<FlowgladNode.Subscriptions.SubscriptionCreateResponse>;
    /**
     * Create a usage event for a customer.
     * NOTE: this method makes two API calls, including one to get the customer.
     * If you are to create usages en masse with minimum latency,
     * you should use `FlowgladServerAdmin.createUsageEvent` instead.
     * @param params - The parameters for the usage event.
     * @returns The created usage event.
     */
    createUsageEvent: (params: CreateUsageEventParams) => Promise<FlowgladNode.UsageEvents.UsageEventCreateResponse>;
    /**
     * Create multiple usage events in a single request.
     * NOTE: this method is more efficient than calling `createUsageEvent` multiple times.
     * @param params - The parameters containing an array of usage events.
     * @returns The created usage events.
     * @throws {Error} If any subscription in the bulk request is not owned by the authenticated customer.
     */
    bulkCreateUsageEvents: (params: BulkCreateUsageEventsParams) => Promise<{
        usageEvents: FlowgladNode.UsageEvents.UsageEventCreateResponse["usageEvent"][];
    }>;
    getPricingModel: () => Promise<{
        pricingModel: FlowgladNode.PricingModels.PricingModelRetrieveResponse["pricingModel"];
    }>;
    /**
     * Get usage meter balances for the authenticated customer.
     *
     * By default, returns balances for all current subscriptions.
     * Optionally filter by a specific subscriptionId.
     *
     * @param params - Optional parameters for fetching usage balances
     * @param params.subscriptionId - Optional. Filter to a specific subscription.
     *
     * @returns A promise that resolves to an object containing usage meter balances
     *
     * @throws {Error} If the customer is not authenticated
     *
     * @example
     * // Get all usage meter balances for current subscriptions
     * const { usageMeterBalances } = await flowglad.getUsageMeterBalances()
     *
     * @example
     * // Get usage balances for a specific subscription
     * const { usageMeterBalances } = await flowglad.getUsageMeterBalances({
     *   subscriptionId: 'sub_123'
     * })
     */
    getUsageMeterBalances: (params?: GetUsageMeterBalancesParams) => Promise<GetUsageMeterBalancesResponse>;
    private deriveSubscriptionId;
    /**
     * Get all resources and their usage for the customer's subscription.
     *
     * Returns capacity, claimed count, and available count for all resources
     * in the subscription's pricing model.
     *
     * @param params - Optional parameters for fetching resources
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     *
     * @returns A promise that resolves to an object containing an array of resources with usage data
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     *
     * @example
     * // Get all resources for the customer's subscription
     * const { resources } = await flowglad.getResourceUsages()
     * for (const resource of resources) {
     *   console.log(`${resource.resourceSlug}: ${resource.claimed}/${resource.capacity} used`)
     * }
     *
     * @example
     * // Get resources for a specific subscription
     * const { resources } = await flowglad.getResourceUsages({ subscriptionId: 'sub_123' })
     */
    getResourceUsages: (params?: FlowgladNode.ResourceClaims.ResourceClaimListUsagesParams & {
        subscriptionId?: string;
    }) => Promise<{
        resources: ResourceUsage[];
    }>;
    /**
     * Get usage for a single resource for the customer's subscription.
     *
     * Returns capacity, claimed count, available count, and active claims
     * for a specific resource identified by slug or ID.
     *
     * @param params - Parameters for fetching resource usage
     * @param params.resourceSlug - The slug identifying the resource type (e.g., 'seats', 'api_keys')
     * @param params.resourceId - Alternative to resourceSlug: The ID of the resource
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     *
     * @returns A promise that resolves to an object containing usage data and active claims
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     *
     * @example
     * // Get usage for seats resource by slug
     * const { usage, claims } = await flowglad.getResourceUsage({ resourceSlug: 'seats' })
     * console.log(`${usage.claimed}/${usage.capacity} seats used`)
     *
     * @example
     * // Get usage for a specific subscription
     * const { usage, claims } = await flowglad.getResourceUsage({
     *   resourceSlug: 'seats',
     *   subscriptionId: 'sub_123'
     * })
     */
    getResourceUsage: (params: ResourceIdentifier & {
        subscriptionId?: string;
    }) => Promise<FlowgladNode.ResourceClaims.ResourceClaimRetrieveUsageResponse>;
    /**
     * Claim resources from a subscription's capacity.
     *
     * Resources represent claimable capacity like seats, API keys, or other
     * countable entitlements. This method reserves capacity from the subscription's
     * available pool.
     *
     * ## Modes
     *
     * Choose ONE of the following modes per call:
     *
     * ### Anonymous Claims Mode
     * Use `quantity` to claim N anonymous resources. These are interchangeable
     * and released in FIFO order when releasing by quantity.
     *
     * ### Named Claims Mode
     * Use `externalId` or `externalIds` to claim resources with identifiers.
     * These are idempotent - claiming the same externalId twice returns the
     * existing claim without creating a duplicate.
     *
     * @param params - Parameters for claiming resources
     * @param params.resourceSlug - The slug identifying the resource type (e.g., 'seats', 'api_keys')
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     * @param params.quantity - Anonymous mode: Number of anonymous resources to claim
     * @param params.externalId - Named mode: Single identifier for a named resource
     * @param params.externalIds - Named mode: Array of identifiers for multiple named resources
     * @param params.metadata - Optional key-value data to attach to claims
     *
     * @returns A promise that resolves to an object containing the created claims and updated usage
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     * @throws {Error} If insufficient capacity is available to fulfill the claim
     *
     * @example
     * // Claim 3 anonymous seats (anonymous mode)
     * const result = await flowglad.claimResource({
     *   resourceSlug: 'seats',
     *   quantity: 3
     * })
     *
     * @example
     * // Claim a specific seat for a user (named mode, idempotent)
     * const result = await flowglad.claimResource({
     *   resourceSlug: 'seats',
     *   externalId: 'user_123',
     *   metadata: { assignedTo: 'John Doe' }
     * })
     *
     * @example
     * // Claim multiple named seats at once
     * const result = await flowglad.claimResource({
     *   resourceSlug: 'seats',
     *   externalIds: ['user_123', 'user_456', 'user_789']
     * })
     */
    claimResource: (params: ClaimResourceParams) => Promise<FlowgladNode.ResourceClaimClaimResponse>;
    /**
     * Release claimed resources back to the subscription's available pool.
     *
     * ## Modes
     *
     * Choose ONE of the following modes per call:
     *
     * ### Anonymous Mode
     * Use `quantity` to release N anonymous claims in FIFO order (oldest first).
     *
     * ### Named Mode by External ID
     * Use `externalId` or `externalIds` to release specific named claims.
     *
     * ### Direct Mode
     * Use `claimIds` to release specific claims by their database IDs.
     *
     * @param params - Parameters for releasing resources
     * @param params.resourceSlug - The slug identifying the resource type
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     * @param params.quantity - Anonymous mode: Number of anonymous claims to release (FIFO)
     * @param params.externalId - Named mode: Single identifier to release
     * @param params.externalIds - Named mode: Array of identifiers to release
     * @param params.claimIds - Direct mode: Array of claim IDs to release
     *
     * @returns A promise that resolves to an object containing the released claims and updated usage
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     *
     * @example
     * // Release 2 anonymous seats (anonymous mode, FIFO)
     * const result = await flowglad.releaseResource({
     *   resourceSlug: 'seats',
     *   quantity: 2
     * })
     *
     * @example
     * // Release a specific user's seat (named mode)
     * const result = await flowglad.releaseResource({
     *   resourceSlug: 'seats',
     *   externalId: 'user_123'
     * })
     *
     * @example
     * // Release multiple users' seats at once
     * const result = await flowglad.releaseResource({
     *   resourceSlug: 'seats',
     *   externalIds: ['user_123', 'user_456']
     * })
     *
     * @example
     * // Release specific claims by their IDs
     * const result = await flowglad.releaseResource({
     *   resourceSlug: 'seats',
     *   claimIds: ['claim_abc', 'claim_def']
     * })
     */
    releaseResource: (params: ReleaseResourceParams) => Promise<FlowgladNode.ResourceClaimReleaseResponse>;
    /**
     * List active resource claims for a subscription.
     *
     * Returns all active (unreleased) claims for the customer's subscription.
     * Can optionally filter by resource type using the resourceSlug parameter.
     *
     * @param params - Optional parameters for listing claims
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     * @param params.resourceSlug - Optional. Filter to specific resource type.
     *
     * @returns A promise that resolves to an object containing an array of active claims
     *
     * @throws {Error} If the customer is not authenticated
     * @throws {Error} If no active subscription is found for the customer
     * @throws {Error} If the customer has multiple active subscriptions and no subscriptionId is provided
     * @throws {Error} If the specified subscription is not owned by the authenticated customer
     *
     * @example
     * // List all active claims for the subscription
     * const { claims } = await flowglad.listResourceClaims()
     * console.log(`Total active claims: ${claims.length}`)
     *
     * @example
     * // List only seat claims
     * const { claims } = await flowglad.listResourceClaims({ resourceSlug: 'seats' })
     * const namedSeats = claims.filter(c => c.externalId !== null)
     * console.log(`Named seats: ${namedSeats.length}`)
     *
     * @example
     * // List claims for a specific subscription
     * const { claims } = await flowglad.listResourceClaims({
     *   subscriptionId: 'sub_123',
     *   resourceSlug: 'api_keys'
     * })
     */
    listResourceClaims: (params?: ListResourceClaimsParams) => Promise<{
        claims: ResourceClaim[];
    }>;
    /**
     * Archives a customer by setting archived=true and canceling all active subscriptions.
     *
     * This is a dedicated method for archiving customers because archiving is a significant
     * state change with cascade effects (subscription cancellation), not just a field update.
     *
     * Behavior:
     * - If customer is already archived, returns immediately (idempotent)
     * - Cancels all active subscriptions with reason 'customer_archived'
     * - Sets archived=true on the customer
     *
     * After archiving:
     * - The customer's externalId is freed for reuse by a new customer
     * - ExternalId lookups will not return this customer by default
     * - Operations that create records attached to this customer will be blocked
     *
     * @param externalId - The external ID of the customer to archive
     * @returns The archived customer record
     */
    archiveCustomer: (externalId: string) => Promise<FlowgladNode.Customers.CustomerClientSelectSchema>;
}
