import {
  __spreadValues
} from "./chunk-2MM5EJJX.mjs";
import { z } from "zod";
import {
  FlowgladActionKey,
  HTTPMethod
} from "./types/sdk.mjs";
const createCoreCheckoutSessionSchema = z.object({
  successUrl: z.url(),
  cancelUrl: z.url(),
  outputMetadata: z.record(z.string(), z.any()).optional(),
  outputName: z.string().optional()
});
const checkoutSessionWithPriceId = createCoreCheckoutSessionSchema.extend({
  priceId: z.string(),
  priceSlug: z.never().optional(),
  // Explicitly disallow
  quantity: z.number().optional().default(1)
});
const checkoutSessionWithPriceSlug = createCoreCheckoutSessionSchema.extend({
  priceSlug: z.string(),
  priceId: z.never().optional(),
  // Explicitly disallow
  quantity: z.number().optional().default(1)
});
const createProductCheckoutSessionSchema = z.union([
  checkoutSessionWithPriceId,
  checkoutSessionWithPriceSlug
]);
const createAddPaymentMethodCheckoutSessionSchema = createCoreCheckoutSessionSchema.extend({
  targetSubscriptionId: z.string().optional()
});
const createActivateSubscriptionCheckoutSessionSchema = createCoreCheckoutSessionSchema.extend({
  targetSubscriptionId: z.string()
});
const subscriptionCancellationTiming = {
  AtEndOfCurrentBillingPeriod: "at_end_of_current_billing_period",
  Immediately: "immediately"
};
const cancellationParametersSchema = z.discriminatedUnion("timing", [
  z.object({
    timing: z.literal(
      subscriptionCancellationTiming.AtEndOfCurrentBillingPeriod
    )
  }),
  z.object({
    timing: z.literal(subscriptionCancellationTiming.Immediately)
  })
]);
const cancelSubscriptionSchema = z.object({
  id: z.string(),
  cancellation: cancellationParametersSchema
});
const uncancelSubscriptionSchema = z.object({
  id: z.string()
});
const subscriptionAdjustmentTiming = {
  Immediately: "immediately",
  AtEndOfCurrentBillingPeriod: "at_end_of_current_billing_period",
  Auto: "auto"
};
const subscriptionAdjustmentTimingSchema = z.enum([
  subscriptionAdjustmentTiming.Immediately,
  subscriptionAdjustmentTiming.AtEndOfCurrentBillingPeriod,
  subscriptionAdjustmentTiming.Auto
]);
const terseSubscriptionItemWithPriceId = z.object({
  priceId: z.string(),
  priceSlug: z.never().optional(),
  quantity: z.number().int().positive().optional().default(1)
});
const terseSubscriptionItemWithPriceSlug = z.object({
  priceSlug: z.string(),
  priceId: z.never().optional(),
  quantity: z.number().int().positive().optional().default(1)
});
const terseSubscriptionItemSchema = z.union([
  terseSubscriptionItemWithPriceId,
  terseSubscriptionItemWithPriceSlug
]);
const adjustmentCommonOptions = {
  subscriptionId: z.string().optional(),
  timing: subscriptionAdjustmentTimingSchema.optional().default(subscriptionAdjustmentTiming.Auto),
  prorate: z.boolean().optional()
};
const adjustSubscriptionByPriceSlugSchema = z.object(__spreadValues({
  priceSlug: z.string(),
  priceId: z.never().optional(),
  subscriptionItems: z.never().optional(),
  quantity: z.number().int().positive().optional().default(1)
}, adjustmentCommonOptions));
const adjustSubscriptionByPriceIdSchema = z.object(__spreadValues({
  priceId: z.string(),
  priceSlug: z.never().optional(),
  subscriptionItems: z.never().optional(),
  quantity: z.number().int().positive().optional().default(1)
}, adjustmentCommonOptions));
const adjustSubscriptionByItemsSchema = z.object(__spreadValues({
  subscriptionItems: z.array(terseSubscriptionItemSchema).min(1),
  priceId: z.never().optional(),
  priceSlug: z.never().optional(),
  quantity: z.never().optional()
}, adjustmentCommonOptions));
const adjustSubscriptionParamsSchema = z.union([
  adjustSubscriptionByPriceSlugSchema,
  adjustSubscriptionByPriceIdSchema,
  adjustSubscriptionByItemsSchema
]);
const baseUsageEventFields = z.object({
  amount: z.number(),
  subscriptionId: z.string(),
  properties: z.record(z.string(), z.unknown()).optional(),
  transactionId: z.string(),
  usageDate: z.number().optional()
});
const usageEventWithPriceId = baseUsageEventFields.extend({
  priceId: z.string(),
  priceSlug: z.never().optional(),
  // Explicitly disallow
  usageMeterId: z.never().optional(),
  // Explicitly disallow
  usageMeterSlug: z.never().optional()
  // Explicitly disallow
});
const usageEventWithPriceSlug = baseUsageEventFields.extend({
  priceSlug: z.string(),
  priceId: z.never().optional(),
  // Explicitly disallow
  usageMeterId: z.never().optional(),
  // Explicitly disallow
  usageMeterSlug: z.never().optional()
  // Explicitly disallow
});
const usageEventWithUsageMeterId = baseUsageEventFields.extend({
  usageMeterId: z.string(),
  priceId: z.never().optional(),
  // Explicitly disallow
  priceSlug: z.never().optional(),
  // Explicitly disallow
  usageMeterSlug: z.never().optional()
  // Explicitly disallow
});
const usageEventWithUsageMeterSlug = baseUsageEventFields.extend({
  usageMeterSlug: z.string(),
  priceId: z.never().optional(),
  // Explicitly disallow
  priceSlug: z.never().optional(),
  // Explicitly disallow
  usageMeterId: z.never().optional()
  // Explicitly disallow
});
const createUsageEventSchema = z.union([
  usageEventWithPriceId,
  usageEventWithPriceSlug,
  usageEventWithUsageMeterId,
  usageEventWithUsageMeterSlug
]);
const bulkCreateUsageEventsSchema = z.object({
  usageEvents: z.array(createUsageEventSchema).min(1)
});
const clientBaseUsageEventFields = z.object({
  amount: z.number().optional(),
  subscriptionId: z.string().optional(),
  properties: z.record(z.string(), z.unknown()).optional(),
  transactionId: z.string().optional(),
  usageDate: z.number().optional()
});
const clientUsageEventWithPriceId = clientBaseUsageEventFields.extend(
  {
    priceId: z.string(),
    priceSlug: z.never().optional(),
    usageMeterId: z.never().optional(),
    usageMeterSlug: z.never().optional()
  }
);
const clientUsageEventWithPriceSlug = clientBaseUsageEventFields.extend({
  priceSlug: z.string(),
  priceId: z.never().optional(),
  usageMeterId: z.never().optional(),
  usageMeterSlug: z.never().optional()
});
const clientUsageEventWithUsageMeterId = clientBaseUsageEventFields.extend({
  usageMeterId: z.string(),
  priceId: z.never().optional(),
  priceSlug: z.never().optional(),
  usageMeterSlug: z.never().optional()
});
const clientUsageEventWithUsageMeterSlug = clientBaseUsageEventFields.extend({
  usageMeterSlug: z.string(),
  priceId: z.never().optional(),
  priceSlug: z.never().optional(),
  usageMeterId: z.never().optional()
});
const clientCreateUsageEventSchema = z.union([
  clientUsageEventWithPriceId,
  clientUsageEventWithPriceSlug,
  clientUsageEventWithUsageMeterId,
  clientUsageEventWithUsageMeterSlug
]);
const createSubscriptionCoreSchema = z.object({
  customerId: z.string(),
  quantity: z.number().optional(),
  startDate: z.string().datetime().optional(),
  trialEnd: z.number().optional().describe(
    `Epoch time in milliseconds of when the trial ends. If not provided, defaults to startDate + the associated price's trialPeriodDays`
  ),
  metadata: z.record(
    z.string(),
    z.union([z.string(), z.number(), z.boolean()])
  ).optional(),
  name: z.string().optional(),
  backupPaymentMethodId: z.string().optional(),
  defaultPaymentMethodId: z.string().optional(),
  interval: z.enum(["day", "week", "month", "year"]).optional(),
  intervalCount: z.number().optional(),
  doNotCharge: z.boolean().optional().default(false)
});
const createSubscriptionWithPriceId = createSubscriptionCoreSchema.extend({
  priceId: z.string(),
  priceSlug: z.never().optional()
  // Explicitly disallow
});
const createSubscriptionWithPriceSlug = createSubscriptionCoreSchema.extend({
  priceSlug: z.string(),
  priceId: z.never().optional()
  // Explicitly disallow
});
const createSubscriptionSchema = z.union([
  createSubscriptionWithPriceId,
  createSubscriptionWithPriceSlug
]);
const billingAddressSchema = z.object({
  name: z.string().optional(),
  firstName: z.string().optional(),
  lastName: z.string().optional(),
  email: z.string().email().optional(),
  address: z.object({
    name: z.string().optional(),
    line1: z.string().nullable(),
    line2: z.string().nullable(),
    city: z.string().nullable(),
    state: z.string().nullable(),
    postal_code: z.string().nullable(),
    country: z.string()
  }),
  phone: z.string().optional()
});
const updateCustomerInputSchema = z.object({
  id: z.string(),
  name: z.string().optional(),
  email: z.string().email().optional(),
  phone: z.string().optional(),
  billingAddress: billingAddressSchema.optional()
});
const updateCustomerSchema = z.object({
  customer: updateCustomerInputSchema,
  externalId: z.string()
});
const getResourcesSchema = z.object({
  subscriptionId: z.string().optional()
});
const claimResourceSchema = z.object({
  resourceSlug: z.string(),
  subscriptionId: z.string().optional(),
  metadata: z.record(
    z.string(),
    z.union([z.string().max(500), z.number(), z.boolean()])
  ).optional(),
  quantity: z.number().int().positive().optional().describe(
    "Create N anonymous claims without external identifiers"
  ),
  externalId: z.string().max(255).optional().describe("Create a named claim with this external identifier"),
  externalIds: z.array(z.string().max(255)).nonempty().optional().describe(
    "Create multiple named claims with these external identifiers"
  )
}).refine(
  (data) => {
    const provided = [
      data.quantity,
      data.externalId,
      data.externalIds
    ].filter((v) => v !== void 0);
    return provided.length === 1;
  },
  {
    message: "Exactly one of quantity, externalId, or externalIds must be provided"
  }
);
const releaseResourceSchema = z.object({
  resourceSlug: z.string(),
  subscriptionId: z.string().optional(),
  quantity: z.number().int().positive().optional().describe("Release N anonymous claims (FIFO)"),
  externalId: z.string().max(255).optional().describe("Release a named claim by external identifier"),
  externalIds: z.array(z.string().max(255)).nonempty().optional().describe(
    "Release multiple named claims by external identifiers"
  ),
  claimIds: z.array(z.string()).nonempty().optional().describe("Release specific claims by their IDs")
}).refine(
  (data) => {
    const provided = [
      data.quantity,
      data.externalId,
      data.externalIds,
      data.claimIds
    ].filter((v) => v !== void 0);
    return provided.length === 1;
  },
  {
    message: "Exactly one of quantity, externalId, externalIds, or claimIds must be provided"
  }
);
const listResourceClaimsSchema = z.object({
  subscriptionId: z.string().optional(),
  resourceSlug: z.string().optional()
});
const getResourceUsageSchema = z.object({
  subscriptionId: z.string().optional()
}).and(
  z.union([
    z.object({ resourceSlug: z.string() }),
    z.object({ resourceId: z.string() })
  ])
);
const getUsageMeterBalancesSchema = z.object({
  subscriptionId: z.string().optional()
}).strict();
const flowgladActionValidators = {
  [FlowgladActionKey.GetCustomerBilling]: {
    method: HTTPMethod.POST,
    inputValidator: z.object({
      externalId: z.string()
    })
  },
  [FlowgladActionKey.FindOrCreateCustomer]: {
    method: HTTPMethod.POST,
    inputValidator: z.object({
      externalId: z.string()
    })
  },
  [FlowgladActionKey.CreateAddPaymentMethodCheckoutSession]: {
    method: HTTPMethod.POST,
    inputValidator: createAddPaymentMethodCheckoutSessionSchema
  },
  [FlowgladActionKey.CreateActivateSubscriptionCheckoutSession]: {
    method: HTTPMethod.POST,
    inputValidator: createActivateSubscriptionCheckoutSessionSchema
  },
  [FlowgladActionKey.CreateCheckoutSession]: {
    method: HTTPMethod.POST,
    inputValidator: createProductCheckoutSessionSchema
  },
  [FlowgladActionKey.CancelSubscription]: {
    method: HTTPMethod.POST,
    inputValidator: cancelSubscriptionSchema
  },
  [FlowgladActionKey.UncancelSubscription]: {
    method: HTTPMethod.POST,
    inputValidator: uncancelSubscriptionSchema
  },
  [FlowgladActionKey.AdjustSubscription]: {
    method: HTTPMethod.POST,
    inputValidator: adjustSubscriptionParamsSchema
  },
  [FlowgladActionKey.CreateSubscription]: {
    method: HTTPMethod.POST,
    inputValidator: createSubscriptionSchema
  },
  [FlowgladActionKey.UpdateCustomer]: {
    method: HTTPMethod.POST,
    inputValidator: updateCustomerSchema
  },
  [FlowgladActionKey.CreateUsageEvent]: {
    method: HTTPMethod.POST,
    inputValidator: clientCreateUsageEventSchema
  },
  [FlowgladActionKey.GetResourceUsages]: {
    method: HTTPMethod.POST,
    inputValidator: getResourcesSchema
  },
  [FlowgladActionKey.ClaimResource]: {
    method: HTTPMethod.POST,
    inputValidator: claimResourceSchema
  },
  [FlowgladActionKey.ReleaseResource]: {
    method: HTTPMethod.POST,
    inputValidator: releaseResourceSchema
  },
  [FlowgladActionKey.ListResourceClaims]: {
    method: HTTPMethod.POST,
    inputValidator: listResourceClaimsSchema
  },
  [FlowgladActionKey.GetResourceUsage]: {
    method: HTTPMethod.POST,
    inputValidator: getResourceUsageSchema
  },
  [FlowgladActionKey.GetPricingModel]: {
    method: HTTPMethod.POST,
    inputValidator: z.object({}).strict()
  },
  [FlowgladActionKey.GetUsageMeterBalances]: {
    method: HTTPMethod.POST,
    inputValidator: getUsageMeterBalancesSchema
  }
};
export {
  adjustSubscriptionParamsSchema,
  billingAddressSchema,
  bulkCreateUsageEventsSchema,
  cancelSubscriptionSchema,
  claimResourceSchema,
  clientCreateUsageEventSchema,
  createActivateSubscriptionCheckoutSessionSchema,
  createAddPaymentMethodCheckoutSessionSchema,
  createProductCheckoutSessionSchema,
  createSubscriptionSchema,
  createUsageEventSchema,
  flowgladActionValidators,
  getResourceUsageSchema,
  getResourcesSchema,
  getUsageMeterBalancesSchema,
  listResourceClaimsSchema,
  releaseResourceSchema,
  subscriptionAdjustmentTiming,
  subscriptionAdjustmentTimingSchema,
  terseSubscriptionItemSchema,
  uncancelSubscriptionSchema,
  updateCustomerInputSchema,
  updateCustomerSchema
};
//# sourceMappingURL=actions.mjs.map