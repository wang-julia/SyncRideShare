import { APIResource } from "../core/resource.mjs";
import * as Shared from "./shared.mjs";
import { APIPromise } from "../core/api-promise.mjs";
import { RequestOptions } from "../internal/request-options.mjs";
export declare class UsageMeters extends APIResource {
    /**
     * Create Usage Meter
     */
    create(body: UsageMeterCreateParams, options?: RequestOptions): APIPromise<UsageMeterCreateResponse>;
    /**
     * Get Usage Meter
     */
    retrieve(id: string, options?: RequestOptions): APIPromise<UsageMeterRetrieveResponse>;
    /**
     * Update Usage Meter
     */
    update(id: string, body: UsageMeterUpdateParams, options?: RequestOptions): APIPromise<UsageMeterUpdateResponse>;
    /**
     * List Usage Meters
     */
    list(query?: UsageMeterListParams | null | undefined, options?: RequestOptions): APIPromise<UsageMeterListResponse>;
}
export interface UsageMeterCreateResponse {
    usageMeter: Shared.UsageMeterClientSelectSchema;
}
export interface UsageMeterRetrieveResponse {
    usageMeter: Shared.UsageMeterClientSelectSchema;
}
export interface UsageMeterUpdateResponse {
    usageMeter: Shared.UsageMeterClientSelectSchema;
}
export interface UsageMeterListResponse {
    data: Array<Shared.UsageMeterClientSelectSchema>;
    hasMore: boolean;
    total: number;
    currentCursor?: string;
    nextCursor?: string;
}
export interface UsageMeterCreateParams {
    usageMeter: UsageMeterCreateParams.UsageMeter;
    price?: UsageMeterCreateParams.Price;
}
export declare namespace UsageMeterCreateParams {
    interface UsageMeter {
        name: string;
        pricingModelId: string;
        slug: string;
        /**
         * The type of aggregation to perform on the usage meter. Defaults to "sum", which
         * aggregates all the usage event amounts for the billing period.
         * "count_distinct_properties" counts the number of distinct properties in the
         * billing period for a given meter.
         */
        aggregationType?: 'sum' | 'count_distinct_properties';
    }
    interface Price {
        type?: 'single_payment' | 'subscription' | 'usage';
        unitPrice?: number;
        usageEventsPerUnit?: number;
    }
}
export interface UsageMeterUpdateParams {
    usageMeter: UsageMeterUpdateParams.UsageMeter;
}
export declare namespace UsageMeterUpdateParams {
    interface UsageMeter {
        id: string;
        /**
         * The type of aggregation to perform on the usage meter. Defaults to "sum", which
         * aggregates all the usage event amounts for the billing period.
         * "count_distinct_properties" counts the number of distinct properties in the
         * billing period for a given meter.
         */
        aggregationType?: 'sum' | 'count_distinct_properties';
        name?: string;
        slug?: string;
    }
}
export interface UsageMeterListParams {
    cursor?: string;
    limit?: string;
}
export declare namespace UsageMeters {
    export { type UsageMeterCreateResponse as UsageMeterCreateResponse, type UsageMeterRetrieveResponse as UsageMeterRetrieveResponse, type UsageMeterUpdateResponse as UsageMeterUpdateResponse, type UsageMeterListResponse as UsageMeterListResponse, type UsageMeterCreateParams as UsageMeterCreateParams, type UsageMeterUpdateParams as UsageMeterUpdateParams, type UsageMeterListParams as UsageMeterListParams, };
}
//# sourceMappingURL=usage-meters.d.mts.map