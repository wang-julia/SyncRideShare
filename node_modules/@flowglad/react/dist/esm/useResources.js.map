{"version":3,"sources":["../../src/useResources.tsx"],"sourcesContent":["'use client'\nimport {\n  type ClaimResourceParams,\n  FlowgladActionKey,\n  flowgladActionValidators,\n  type ReleaseResourceParams,\n  type ResourceClaim,\n  type ResourceUsage,\n} from '@flowglad/shared'\nimport {\n  useMutation,\n  useQuery,\n  useQueryClient,\n} from '@tanstack/react-query'\nimport { useCallback } from 'react'\nimport { useFlowgladConfig } from './FlowgladConfigContext'\nimport { getFlowgladRoute } from './FlowgladContext'\n\n/** Query key for resources caching */\nexport const RESOURCES_QUERY_KEY = 'flowglad-resources'\n\n/** Query key for resource claims caching */\nexport const RESOURCE_CLAIMS_QUERY_KEY = 'flowglad-resource-claims'\n\n/**\n * Mock resources data for dev mode.\n */\nconst mockResources: ResourceUsage[] = [\n  {\n    resourceSlug: 'seats',\n    resourceId: 'res_mock_seats',\n    capacity: 10,\n    claimed: 3,\n    available: 7,\n  },\n  {\n    resourceSlug: 'api_keys',\n    resourceId: 'res_mock_api_keys',\n    capacity: 5,\n    claimed: 2,\n    available: 3,\n  },\n]\n\n/**\n * Mock resource claim for dev mode.\n */\nconst createMockClaim = (\n  resourceSlug: string,\n  externalId: string | null = null\n): ResourceClaim => ({\n  id: `claim_mock_${Date.now()}`,\n  subscriptionItemFeatureId: 'sif_mock',\n  resourceId: `res_mock_${resourceSlug}`,\n  subscriptionId: 'sub_mock',\n  pricingModelId: 'pm_mock',\n  externalId,\n  claimedAt: Date.now(),\n  releasedAt: null,\n  releaseReason: null,\n  metadata: null,\n  createdAt: Date.now(),\n  updatedAt: Date.now(),\n  livemode: false,\n  organizationId: 'org_mock',\n})\n\n/**\n * Result type for the useResources hook.\n */\nexport interface UseResourcesResult {\n  /** All resources with usage data. Undefined until loaded. */\n  resources: ResourceUsage[] | undefined\n  /** Loading state for initial fetch */\n  isLoading: boolean\n  /** Error if fetch failed */\n  error: Error | null\n  /**\n   * Claim resources from subscription capacity.\n   * Automatically invalidates the resources cache on success.\n   *\n   * Supports three mutually exclusive modes:\n   * - `quantity`: Create N anonymous claims without external identifiers\n   * - `externalId`: Create a named claim with a single external identifier (idempotent)\n   * - `externalIds`: Create multiple named claims with external identifiers (idempotent)\n   *\n   * @param params.resourceSlug - The resource type to claim (e.g., 'seats', 'api_keys')\n   * @param params.quantity - Anonymous claims mode: Number of resources to claim\n   * @param params.externalId - Named claim mode: Single identifier for a named claim\n   * @param params.externalIds - Named claims mode: Array of identifiers for multiple named claims\n   * @param params.metadata - Optional key-value data to attach to claims\n   * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.\n   *\n   * @returns Promise resolving to the created claims and updated usage\n   *\n   * @example\n   * // Anonymous claims - claim 3 seats\n   * await claim({ resourceSlug: 'seats', quantity: 3 })\n   *\n   * @example\n   * // Named claim - assign seat to specific user (idempotent)\n   * await claim({ resourceSlug: 'seats', externalId: 'user_123' })\n   */\n  claim: (params: ClaimResourceParams) => Promise<{\n    claims: ResourceClaim[]\n    usage: ResourceUsage\n  }>\n  /**\n   * Release claimed resources back to the subscription's available pool.\n   * Automatically invalidates the resources cache on success.\n   *\n   * Supports four mutually exclusive modes:\n   * - `quantity`: Release N anonymous claims in FIFO order (oldest first)\n   * - `externalId`: Release a named claim by its external identifier\n   * - `externalIds`: Release multiple named claims by their external identifiers\n   * - `claimIds`: Release specific claims by their database IDs\n   *\n   * @param params.resourceSlug - The resource type to release\n   * @param params.quantity - Anonymous release mode: Number to release (FIFO)\n   * @param params.externalId - Named release mode: Single identifier to release\n   * @param params.externalIds - Named release mode: Array of identifiers to release\n   * @param params.claimIds - Direct mode: Specific claim IDs to release\n   * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.\n   *\n   * @returns Promise resolving to the released claims and updated usage\n   *\n   * @example\n   * // Release 2 anonymous seats (FIFO)\n   * await release({ resourceSlug: 'seats', quantity: 2 })\n   *\n   * @example\n   * // Release a specific user's seat\n   * await release({ resourceSlug: 'seats', externalId: 'user_123' })\n   */\n  release: (params: ReleaseResourceParams) => Promise<{\n    releasedClaims: ResourceClaim[]\n    usage: ResourceUsage\n  }>\n}\n\n/**\n * Hook to access all resources for the current customer's subscription.\n *\n * Fetches resource usage on mount and provides claim/release mutations\n * that automatically invalidate the cache, keeping the UI in sync.\n *\n * Must be used within a `FlowgladProvider`.\n *\n * @returns Object containing resources array, loading state, error, and mutation functions\n *\n * @example\n * function TeamMembers() {\n *   const { resources, claim, release, isLoading } = useResources()\n *\n *   if (isLoading) return <Spinner />\n *\n *   const seats = resources?.find(r => r.resourceSlug === 'seats')\n *\n *   return (\n *     <div>\n *       <p>{seats?.claimed} / {seats?.capacity} seats used</p>\n *       <button\n *         onClick={() => claim({ resourceSlug: 'seats', quantity: 1 })}\n *         disabled={seats?.available === 0}\n *       >\n *         Add Seat\n *       </button>\n *     </div>\n *   )\n * }\n */\nexport const useResources = (): UseResourcesResult => {\n  const { baseURL, betterAuthBasePath, requestConfig, __devMode } =\n    useFlowgladConfig()\n  const queryClient = useQueryClient()\n\n  // Query for fetching resources\n  const {\n    data: resources,\n    isLoading,\n    error,\n  } = useQuery<ResourceUsage[], Error>({\n    queryKey: [RESOURCES_QUERY_KEY],\n    queryFn: async () => {\n      if (__devMode) {\n        // Return mock data in dev mode without making network calls\n        return mockResources\n      }\n\n      const flowgladRoute = getFlowgladRoute(\n        baseURL,\n        betterAuthBasePath\n      )\n      const response = await fetch(\n        `${flowgladRoute}/${FlowgladActionKey.GetResourceUsages}`,\n        {\n          // Better Auth endpoints are POST-only (they proxy internally to the correct action method),\n          // while the standalone route handler uses the action's declared method (GET here).\n          method: betterAuthBasePath\n            ? 'POST'\n            : flowgladActionValidators[\n                FlowgladActionKey.GetResourceUsages\n              ].method,\n          headers: {\n            'Content-Type': 'application/json',\n            ...requestConfig?.headers,\n          },\n          ...(betterAuthBasePath ? { body: JSON.stringify({}) } : {}),\n        }\n      )\n\n      const json = await response.json()\n      if (json.error) {\n        throw new Error(\n          json.error.json?.message ||\n            json.error.message ||\n            'Failed to fetch resources'\n        )\n      }\n\n      return json.data.resources as ResourceUsage[]\n    },\n  })\n\n  // Claim mutation\n  const claimMutation = useMutation<\n    { claims: ResourceClaim[]; usage: ResourceUsage },\n    Error,\n    ClaimResourceParams\n  >({\n    mutationFn: async (params) => {\n      if (__devMode) {\n        // Return mock data in dev mode\n        const mockClaims: ResourceClaim[] = []\n        const quantity = params.quantity ?? 1\n        const externalIds =\n          params.externalIds ??\n          (params.externalId ? [params.externalId] : [])\n\n        if (externalIds.length > 0) {\n          for (const extId of externalIds) {\n            mockClaims.push(\n              createMockClaim(params.resourceSlug, extId)\n            )\n          }\n        } else {\n          for (let i = 0; i < quantity; i++) {\n            mockClaims.push(\n              createMockClaim(params.resourceSlug, null)\n            )\n          }\n        }\n\n        const mockResource =\n          mockResources.find(\n            (r) => r.resourceSlug === params.resourceSlug\n          ) ?? mockResources[0]\n\n        return {\n          claims: mockClaims,\n          usage: {\n            ...mockResource,\n            claimed: mockResource.claimed + mockClaims.length,\n            available: mockResource.available - mockClaims.length,\n          },\n        }\n      }\n\n      const flowgladRoute = getFlowgladRoute(\n        baseURL,\n        betterAuthBasePath\n      )\n      const response = await fetch(\n        `${flowgladRoute}/${FlowgladActionKey.ClaimResource}`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...requestConfig?.headers,\n          },\n          body: JSON.stringify(params),\n        }\n      )\n\n      const json = await response.json()\n      if (json.error) {\n        throw new Error(\n          json.error.json?.message ||\n            json.error.message ||\n            'Failed to claim resource'\n        )\n      }\n\n      return json.data as {\n        claims: ResourceClaim[]\n        usage: ResourceUsage\n      }\n    },\n    onSuccess: () => {\n      // Invalidate resources query to refetch and update UI\n      queryClient.invalidateQueries({\n        queryKey: [RESOURCES_QUERY_KEY],\n      })\n      // Also invalidate claims query if it exists\n      queryClient.invalidateQueries({\n        queryKey: [RESOURCE_CLAIMS_QUERY_KEY],\n      })\n    },\n  })\n\n  // Release mutation\n  const releaseMutation = useMutation<\n    { releasedClaims: ResourceClaim[]; usage: ResourceUsage },\n    Error,\n    ReleaseResourceParams\n  >({\n    mutationFn: async (params) => {\n      if (__devMode) {\n        // Return mock data in dev mode\n        const mockReleasedClaims: ResourceClaim[] = []\n        const quantity = params.quantity ?? 1\n        const now = Date.now()\n\n        for (let i = 0; i < quantity; i++) {\n          mockReleasedClaims.push({\n            ...createMockClaim(params.resourceSlug, null),\n            claimedAt: now - 10000, // Claimed 10 seconds ago\n            releasedAt: now,\n          })\n        }\n\n        const mockResource =\n          mockResources.find(\n            (r) => r.resourceSlug === params.resourceSlug\n          ) ?? mockResources[0]\n\n        return {\n          releasedClaims: mockReleasedClaims,\n          usage: {\n            ...mockResource,\n            claimed: Math.max(\n              0,\n              mockResource.claimed - mockReleasedClaims.length\n            ),\n            available: Math.min(\n              mockResource.capacity,\n              mockResource.available + mockReleasedClaims.length\n            ),\n          },\n        }\n      }\n\n      const flowgladRoute = getFlowgladRoute(\n        baseURL,\n        betterAuthBasePath\n      )\n      const response = await fetch(\n        `${flowgladRoute}/${FlowgladActionKey.ReleaseResource}`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...requestConfig?.headers,\n          },\n          body: JSON.stringify(params),\n        }\n      )\n\n      const json = await response.json()\n      if (json.error) {\n        throw new Error(\n          json.error.json?.message ||\n            json.error.message ||\n            'Failed to release resource'\n        )\n      }\n\n      return json.data as {\n        releasedClaims: ResourceClaim[]\n        usage: ResourceUsage\n      }\n    },\n    onSuccess: () => {\n      // Invalidate resources query to refetch and update UI\n      queryClient.invalidateQueries({\n        queryKey: [RESOURCES_QUERY_KEY],\n      })\n      // Also invalidate claims query if it exists\n      queryClient.invalidateQueries({\n        queryKey: [RESOURCE_CLAIMS_QUERY_KEY],\n      })\n    },\n  })\n\n  return {\n    resources,\n    isLoading,\n    error: error ?? null,\n    claim: claimMutation.mutateAsync,\n    release: releaseMutation.mutateAsync,\n  }\n}\n\n/**\n * Result type for the useResource hook.\n */\nexport interface UseResourceResult {\n  /** Usage for this specific resource. Undefined until loaded. */\n  usage: ResourceUsage | undefined\n  /**\n   * Active claims for this resource.\n   * Always an array (empty if no claims exist, never undefined).\n   */\n  claims: ResourceClaim[]\n  /** Loading state for initial fetch */\n  isLoading: boolean\n  /** Loading state for claims fetch */\n  isLoadingClaims: boolean\n  /** Error if fetch failed */\n  error: Error | null\n  /**\n   * Claim this resource. The `resourceSlug` is automatically bound.\n   *\n   * Supports three mutually exclusive modes:\n   * - `quantity`: Create N anonymous claims without external identifiers\n   * - `externalId`: Create a named claim with a single external identifier (idempotent)\n   * - `externalIds`: Create multiple named claims with external identifiers (idempotent)\n   *\n   * @param params.quantity - Anonymous claims mode: Number of resources to claim\n   * @param params.externalId - Named claim mode: Single identifier for a named claim\n   * @param params.externalIds - Named claims mode: Array of identifiers for multiple named claims\n   * @param params.metadata - Optional key-value data to attach to claims\n   * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.\n   *\n   * @returns Promise resolving to the created claims and updated usage\n   *\n   * @example\n   * const { claim } = useResource('seats')\n   *\n   * // Anonymous claim\n   * await claim({ quantity: 1 })\n   *\n   * // Named claim (idempotent)\n   * await claim({ externalId: 'user_123' })\n   */\n  claim: (\n    params: Omit<ClaimResourceParams, 'resourceSlug'>\n  ) => Promise<{\n    claims: ResourceClaim[]\n    usage: ResourceUsage\n  }>\n  /**\n   * Release this resource. The `resourceSlug` is automatically bound.\n   *\n   * Supports four mutually exclusive modes:\n   * - `quantity`: Release N anonymous claims in FIFO order (oldest first)\n   * - `externalId`: Release a named claim by its external identifier\n   * - `externalIds`: Release multiple named claims by their external identifiers\n   * - `claimIds`: Release specific claims by their database IDs\n   *\n   * @param params.quantity - Anonymous release mode: Number to release (FIFO)\n   * @param params.externalId - Named release mode: Single identifier to release\n   * @param params.externalIds - Named release mode: Array of identifiers to release\n   * @param params.claimIds - Direct mode: Specific claim IDs to release\n   * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.\n   *\n   * @returns Promise resolving to the released claims and updated usage\n   *\n   * @example\n   * const { release } = useResource('seats')\n   *\n   * // Release anonymous claims (FIFO)\n   * await release({ quantity: 2 })\n   *\n   * // Release by external ID\n   * await release({ externalId: 'user_123' })\n   */\n  release: (\n    params: Omit<ReleaseResourceParams, 'resourceSlug'>\n  ) => Promise<{\n    releasedClaims: ResourceClaim[]\n    usage: ResourceUsage\n  }>\n}\n\n/**\n * Hook to access a specific resource by slug.\n *\n * This is a convenience wrapper around `useResources()` that:\n * - Filters to the specific resource by slug\n * - Fetches claims for this specific resource\n * - Pre-binds `resourceSlug` to claim/release functions\n *\n * Both hooks share the same underlying query cache, so multiple\n * `useResource()` calls don't result in duplicate fetches.\n *\n * Must be used within a `FlowgladProvider`.\n *\n * @param resourceSlug - The resource type to access (e.g., 'seats', 'api_keys')\n *\n * @returns Object containing resource usage, claims array, loading state, error, and mutation functions\n *\n * @example\n * function SeatManager() {\n *   const { usage, claims, claim, release, isLoading } = useResource('seats')\n *\n *   if (isLoading) return <Spinner />\n *\n *   return (\n *     <div>\n *       <p>{usage?.claimed} / {usage?.capacity} seats used</p>\n *\n *       <h3>Active Claims</h3>\n *       <ul>\n *         {claims.map(c => (\n *           <li key={c.id}>\n *             {c.externalId ?? 'Anonymous'} - claimed at {new Date(c.claimedAt).toLocaleString()}\n *             <button onClick={() => release({ claimIds: [c.id] })}>Release</button>\n *           </li>\n *         ))}\n *       </ul>\n *\n *       <button\n *         onClick={() => claim({ quantity: 1 })}\n *         disabled={usage?.available === 0}\n *       >\n *         Add Seat\n *       </button>\n *     </div>\n *   )\n * }\n *\n * @example\n * // Named claim - assign seat to specific user\n * function AssignSeat({ userId }: { userId: string }) {\n *   const { claim, claims } = useResource('seats')\n *\n *   // Check if user already has a seat\n *   const userHasSeat = claims.some(c => c.externalId === userId)\n *\n *   const handleAssign = async () => {\n *     // Named claims are idempotent - safe to call multiple times\n *     await claim({ externalId: userId, metadata: { assignedAt: Date.now() } })\n *   }\n *\n *   return (\n *     <button onClick={handleAssign} disabled={userHasSeat}>\n *       {userHasSeat ? 'Seat Assigned' : 'Assign Seat'}\n *     </button>\n *   )\n * }\n */\nexport const useResource = (\n  resourceSlug: string\n): UseResourceResult => {\n  const { baseURL, betterAuthBasePath, requestConfig, __devMode } =\n    useFlowgladConfig()\n  const {\n    resources,\n    isLoading,\n    error,\n    claim: claimAll,\n    release: releaseAll,\n  } = useResources()\n\n  // Query for fetching claims for this specific resource\n  const {\n    data: claims,\n    isLoading: isLoadingClaims,\n    error: claimsError,\n  } = useQuery<ResourceClaim[], Error>({\n    queryKey: [RESOURCE_CLAIMS_QUERY_KEY, resourceSlug],\n    queryFn: async () => {\n      if (__devMode) {\n        // Return mock claims in dev mode\n        return [\n          createMockClaim(resourceSlug, 'user_mock_1'),\n          createMockClaim(resourceSlug, null),\n        ]\n      }\n\n      const flowgladRoute = getFlowgladRoute(\n        baseURL,\n        betterAuthBasePath\n      )\n      const response = await fetch(\n        `${flowgladRoute}/${FlowgladActionKey.ListResourceClaims}`,\n        {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            ...requestConfig?.headers,\n          },\n          body: JSON.stringify({ resourceSlug }),\n        }\n      )\n\n      const json = await response.json()\n      if (json.error) {\n        throw new Error(\n          json.error.json?.message ||\n            json.error.message ||\n            'Failed to fetch resource claims'\n        )\n      }\n\n      return json.data.claims as ResourceClaim[]\n    },\n  })\n\n  // Find usage for this specific resource\n  const usage = resources?.find(\n    (r) => r.resourceSlug === resourceSlug\n  )\n\n  // Pre-bind resourceSlug to claim function (memoized to prevent re-renders)\n  const claim = useCallback(\n    async (\n      params: Omit<ClaimResourceParams, 'resourceSlug'>\n    ): Promise<{ claims: ResourceClaim[]; usage: ResourceUsage }> => {\n      return claimAll({\n        ...params,\n        resourceSlug,\n      } as ClaimResourceParams)\n    },\n    [claimAll, resourceSlug]\n  )\n\n  // Pre-bind resourceSlug to release function (memoized to prevent re-renders)\n  const release = useCallback(\n    async (\n      params: Omit<ReleaseResourceParams, 'resourceSlug'>\n    ): Promise<{\n      releasedClaims: ResourceClaim[]\n      usage: ResourceUsage\n    }> => {\n      return releaseAll({\n        ...params,\n        resourceSlug,\n      } as ReleaseResourceParams)\n    },\n    [releaseAll, resourceSlug]\n  )\n\n  // Combine errors\n  const combinedError = error ?? claimsError ?? null\n\n  return {\n    usage,\n    claims: claims ?? [], // Always return an array, never undefined\n    isLoading,\n    isLoadingClaims,\n    error: combinedError,\n    claim,\n    release,\n  }\n}\n"],"mappings":"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","names":["_a"]}