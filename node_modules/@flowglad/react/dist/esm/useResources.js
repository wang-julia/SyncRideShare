"use client";
import {
  __async,
  __spreadProps,
  __spreadValues
} from "./chunk-CRTRMMJ7.js";
import {
  FlowgladActionKey,
  flowgladActionValidators
} from "@flowglad/shared";
import {
  useMutation,
  useQuery,
  useQueryClient
} from "@tanstack/react-query";
import { useCallback } from "react";
import { useFlowgladConfig } from "./FlowgladConfigContext";
import { getFlowgladRoute } from "./FlowgladContext";
const RESOURCES_QUERY_KEY = "flowglad-resources";
const RESOURCE_CLAIMS_QUERY_KEY = "flowglad-resource-claims";
const mockResources = [
  {
    resourceSlug: "seats",
    resourceId: "res_mock_seats",
    capacity: 10,
    claimed: 3,
    available: 7
  },
  {
    resourceSlug: "api_keys",
    resourceId: "res_mock_api_keys",
    capacity: 5,
    claimed: 2,
    available: 3
  }
];
const createMockClaim = (resourceSlug, externalId = null) => ({
  id: `claim_mock_${Date.now()}`,
  subscriptionItemFeatureId: "sif_mock",
  resourceId: `res_mock_${resourceSlug}`,
  subscriptionId: "sub_mock",
  pricingModelId: "pm_mock",
  externalId,
  claimedAt: Date.now(),
  releasedAt: null,
  releaseReason: null,
  metadata: null,
  createdAt: Date.now(),
  updatedAt: Date.now(),
  livemode: false,
  organizationId: "org_mock"
});
const useResources = () => {
  const { baseURL, betterAuthBasePath, requestConfig, __devMode } = useFlowgladConfig();
  const queryClient = useQueryClient();
  const {
    data: resources,
    isLoading,
    error
  } = useQuery({
    queryKey: [RESOURCES_QUERY_KEY],
    queryFn: () => __async(null, null, function* () {
      var _a;
      if (__devMode) {
        return mockResources;
      }
      const flowgladRoute = getFlowgladRoute(
        baseURL,
        betterAuthBasePath
      );
      const response = yield fetch(
        `${flowgladRoute}/${FlowgladActionKey.GetResourceUsages}`,
        __spreadValues({
          // Better Auth endpoints are POST-only (they proxy internally to the correct action method),
          // while the standalone route handler uses the action's declared method (GET here).
          method: betterAuthBasePath ? "POST" : flowgladActionValidators[FlowgladActionKey.GetResourceUsages].method,
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, requestConfig == null ? void 0 : requestConfig.headers)
        }, betterAuthBasePath ? { body: JSON.stringify({}) } : {})
      );
      const json = yield response.json();
      if (json.error) {
        throw new Error(
          ((_a = json.error.json) == null ? void 0 : _a.message) || json.error.message || "Failed to fetch resources"
        );
      }
      return json.data.resources;
    })
  });
  const claimMutation = useMutation({
    mutationFn: (params) => __async(null, null, function* () {
      var _a, _b, _c, _d;
      if (__devMode) {
        const mockClaims = [];
        const quantity = (_a = params.quantity) != null ? _a : 1;
        const externalIds = (_b = params.externalIds) != null ? _b : params.externalId ? [params.externalId] : [];
        if (externalIds.length > 0) {
          for (const extId of externalIds) {
            mockClaims.push(
              createMockClaim(params.resourceSlug, extId)
            );
          }
        } else {
          for (let i = 0; i < quantity; i++) {
            mockClaims.push(
              createMockClaim(params.resourceSlug, null)
            );
          }
        }
        const mockResource = (_c = mockResources.find(
          (r) => r.resourceSlug === params.resourceSlug
        )) != null ? _c : mockResources[0];
        return {
          claims: mockClaims,
          usage: __spreadProps(__spreadValues({}, mockResource), {
            claimed: mockResource.claimed + mockClaims.length,
            available: mockResource.available - mockClaims.length
          })
        };
      }
      const flowgladRoute = getFlowgladRoute(
        baseURL,
        betterAuthBasePath
      );
      const response = yield fetch(
        `${flowgladRoute}/${FlowgladActionKey.ClaimResource}`,
        {
          method: "POST",
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, requestConfig == null ? void 0 : requestConfig.headers),
          body: JSON.stringify(params)
        }
      );
      const json = yield response.json();
      if (json.error) {
        throw new Error(
          ((_d = json.error.json) == null ? void 0 : _d.message) || json.error.message || "Failed to claim resource"
        );
      }
      return json.data;
    }),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: [RESOURCES_QUERY_KEY]
      });
      queryClient.invalidateQueries({
        queryKey: [RESOURCE_CLAIMS_QUERY_KEY]
      });
    }
  });
  const releaseMutation = useMutation({
    mutationFn: (params) => __async(null, null, function* () {
      var _a, _b, _c;
      if (__devMode) {
        const mockReleasedClaims = [];
        const quantity = (_a = params.quantity) != null ? _a : 1;
        const now = Date.now();
        for (let i = 0; i < quantity; i++) {
          mockReleasedClaims.push(__spreadProps(__spreadValues({}, createMockClaim(params.resourceSlug, null)), {
            claimedAt: now - 1e4,
            // Claimed 10 seconds ago
            releasedAt: now
          }));
        }
        const mockResource = (_b = mockResources.find(
          (r) => r.resourceSlug === params.resourceSlug
        )) != null ? _b : mockResources[0];
        return {
          releasedClaims: mockReleasedClaims,
          usage: __spreadProps(__spreadValues({}, mockResource), {
            claimed: Math.max(
              0,
              mockResource.claimed - mockReleasedClaims.length
            ),
            available: Math.min(
              mockResource.capacity,
              mockResource.available + mockReleasedClaims.length
            )
          })
        };
      }
      const flowgladRoute = getFlowgladRoute(
        baseURL,
        betterAuthBasePath
      );
      const response = yield fetch(
        `${flowgladRoute}/${FlowgladActionKey.ReleaseResource}`,
        {
          method: "POST",
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, requestConfig == null ? void 0 : requestConfig.headers),
          body: JSON.stringify(params)
        }
      );
      const json = yield response.json();
      if (json.error) {
        throw new Error(
          ((_c = json.error.json) == null ? void 0 : _c.message) || json.error.message || "Failed to release resource"
        );
      }
      return json.data;
    }),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: [RESOURCES_QUERY_KEY]
      });
      queryClient.invalidateQueries({
        queryKey: [RESOURCE_CLAIMS_QUERY_KEY]
      });
    }
  });
  return {
    resources,
    isLoading,
    error: error != null ? error : null,
    claim: claimMutation.mutateAsync,
    release: releaseMutation.mutateAsync
  };
};
const useResource = (resourceSlug) => {
  var _a;
  const { baseURL, betterAuthBasePath, requestConfig, __devMode } = useFlowgladConfig();
  const {
    resources,
    isLoading,
    error,
    claim: claimAll,
    release: releaseAll
  } = useResources();
  const {
    data: claims,
    isLoading: isLoadingClaims,
    error: claimsError
  } = useQuery({
    queryKey: [RESOURCE_CLAIMS_QUERY_KEY, resourceSlug],
    queryFn: () => __async(null, null, function* () {
      var _a2;
      if (__devMode) {
        return [
          createMockClaim(resourceSlug, "user_mock_1"),
          createMockClaim(resourceSlug, null)
        ];
      }
      const flowgladRoute = getFlowgladRoute(
        baseURL,
        betterAuthBasePath
      );
      const response = yield fetch(
        `${flowgladRoute}/${FlowgladActionKey.ListResourceClaims}`,
        {
          method: "POST",
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, requestConfig == null ? void 0 : requestConfig.headers),
          body: JSON.stringify({ resourceSlug })
        }
      );
      const json = yield response.json();
      if (json.error) {
        throw new Error(
          ((_a2 = json.error.json) == null ? void 0 : _a2.message) || json.error.message || "Failed to fetch resource claims"
        );
      }
      return json.data.claims;
    })
  });
  const usage = resources == null ? void 0 : resources.find(
    (r) => r.resourceSlug === resourceSlug
  );
  const claim = useCallback(
    (params) => __async(null, null, function* () {
      return claimAll(__spreadProps(__spreadValues({}, params), {
        resourceSlug
      }));
    }),
    [claimAll, resourceSlug]
  );
  const release = useCallback(
    (params) => __async(null, null, function* () {
      return releaseAll(__spreadProps(__spreadValues({}, params), {
        resourceSlug
      }));
    }),
    [releaseAll, resourceSlug]
  );
  const combinedError = (_a = error != null ? error : claimsError) != null ? _a : null;
  return {
    usage,
    claims: claims != null ? claims : [],
    // Always return an array, never undefined
    isLoading,
    isLoadingClaims,
    error: combinedError,
    claim,
    release
  };
};
export {
  RESOURCES_QUERY_KEY,
  RESOURCE_CLAIMS_QUERY_KEY,
  useResource,
  useResources
};
//# sourceMappingURL=useResources.js.map