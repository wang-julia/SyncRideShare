import { type ClaimResourceParams, type ReleaseResourceParams, type ResourceClaim, type ResourceUsage } from '@flowglad/shared';
/** Query key for resources caching */
export declare const RESOURCES_QUERY_KEY = "flowglad-resources";
/** Query key for resource claims caching */
export declare const RESOURCE_CLAIMS_QUERY_KEY = "flowglad-resource-claims";
/**
 * Result type for the useResources hook.
 */
export interface UseResourcesResult {
    /** All resources with usage data. Undefined until loaded. */
    resources: ResourceUsage[] | undefined;
    /** Loading state for initial fetch */
    isLoading: boolean;
    /** Error if fetch failed */
    error: Error | null;
    /**
     * Claim resources from subscription capacity.
     * Automatically invalidates the resources cache on success.
     *
     * Supports three mutually exclusive modes:
     * - `quantity`: Create N anonymous claims without external identifiers
     * - `externalId`: Create a named claim with a single external identifier (idempotent)
     * - `externalIds`: Create multiple named claims with external identifiers (idempotent)
     *
     * @param params.resourceSlug - The resource type to claim (e.g., 'seats', 'api_keys')
     * @param params.quantity - Anonymous claims mode: Number of resources to claim
     * @param params.externalId - Named claim mode: Single identifier for a named claim
     * @param params.externalIds - Named claims mode: Array of identifiers for multiple named claims
     * @param params.metadata - Optional key-value data to attach to claims
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     *
     * @returns Promise resolving to the created claims and updated usage
     *
     * @example
     * // Anonymous claims - claim 3 seats
     * await claim({ resourceSlug: 'seats', quantity: 3 })
     *
     * @example
     * // Named claim - assign seat to specific user (idempotent)
     * await claim({ resourceSlug: 'seats', externalId: 'user_123' })
     */
    claim: (params: ClaimResourceParams) => Promise<{
        claims: ResourceClaim[];
        usage: ResourceUsage;
    }>;
    /**
     * Release claimed resources back to the subscription's available pool.
     * Automatically invalidates the resources cache on success.
     *
     * Supports four mutually exclusive modes:
     * - `quantity`: Release N anonymous claims in FIFO order (oldest first)
     * - `externalId`: Release a named claim by its external identifier
     * - `externalIds`: Release multiple named claims by their external identifiers
     * - `claimIds`: Release specific claims by their database IDs
     *
     * @param params.resourceSlug - The resource type to release
     * @param params.quantity - Anonymous release mode: Number to release (FIFO)
     * @param params.externalId - Named release mode: Single identifier to release
     * @param params.externalIds - Named release mode: Array of identifiers to release
     * @param params.claimIds - Direct mode: Specific claim IDs to release
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     *
     * @returns Promise resolving to the released claims and updated usage
     *
     * @example
     * // Release 2 anonymous seats (FIFO)
     * await release({ resourceSlug: 'seats', quantity: 2 })
     *
     * @example
     * // Release a specific user's seat
     * await release({ resourceSlug: 'seats', externalId: 'user_123' })
     */
    release: (params: ReleaseResourceParams) => Promise<{
        releasedClaims: ResourceClaim[];
        usage: ResourceUsage;
    }>;
}
/**
 * Hook to access all resources for the current customer's subscription.
 *
 * Fetches resource usage on mount and provides claim/release mutations
 * that automatically invalidate the cache, keeping the UI in sync.
 *
 * Must be used within a `FlowgladProvider`.
 *
 * @returns Object containing resources array, loading state, error, and mutation functions
 *
 * @example
 * function TeamMembers() {
 *   const { resources, claim, release, isLoading } = useResources()
 *
 *   if (isLoading) return <Spinner />
 *
 *   const seats = resources?.find(r => r.resourceSlug === 'seats')
 *
 *   return (
 *     <div>
 *       <p>{seats?.claimed} / {seats?.capacity} seats used</p>
 *       <button
 *         onClick={() => claim({ resourceSlug: 'seats', quantity: 1 })}
 *         disabled={seats?.available === 0}
 *       >
 *         Add Seat
 *       </button>
 *     </div>
 *   )
 * }
 */
export declare const useResources: () => UseResourcesResult;
/**
 * Result type for the useResource hook.
 */
export interface UseResourceResult {
    /** Usage for this specific resource. Undefined until loaded. */
    usage: ResourceUsage | undefined;
    /**
     * Active claims for this resource.
     * Always an array (empty if no claims exist, never undefined).
     */
    claims: ResourceClaim[];
    /** Loading state for initial fetch */
    isLoading: boolean;
    /** Loading state for claims fetch */
    isLoadingClaims: boolean;
    /** Error if fetch failed */
    error: Error | null;
    /**
     * Claim this resource. The `resourceSlug` is automatically bound.
     *
     * Supports three mutually exclusive modes:
     * - `quantity`: Create N anonymous claims without external identifiers
     * - `externalId`: Create a named claim with a single external identifier (idempotent)
     * - `externalIds`: Create multiple named claims with external identifiers (idempotent)
     *
     * @param params.quantity - Anonymous claims mode: Number of resources to claim
     * @param params.externalId - Named claim mode: Single identifier for a named claim
     * @param params.externalIds - Named claims mode: Array of identifiers for multiple named claims
     * @param params.metadata - Optional key-value data to attach to claims
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     *
     * @returns Promise resolving to the created claims and updated usage
     *
     * @example
     * const { claim } = useResource('seats')
     *
     * // Anonymous claim
     * await claim({ quantity: 1 })
     *
     * // Named claim (idempotent)
     * await claim({ externalId: 'user_123' })
     */
    claim: (params: Omit<ClaimResourceParams, 'resourceSlug'>) => Promise<{
        claims: ResourceClaim[];
        usage: ResourceUsage;
    }>;
    /**
     * Release this resource. The `resourceSlug` is automatically bound.
     *
     * Supports four mutually exclusive modes:
     * - `quantity`: Release N anonymous claims in FIFO order (oldest first)
     * - `externalId`: Release a named claim by its external identifier
     * - `externalIds`: Release multiple named claims by their external identifiers
     * - `claimIds`: Release specific claims by their database IDs
     *
     * @param params.quantity - Anonymous release mode: Number to release (FIFO)
     * @param params.externalId - Named release mode: Single identifier to release
     * @param params.externalIds - Named release mode: Array of identifiers to release
     * @param params.claimIds - Direct mode: Specific claim IDs to release
     * @param params.subscriptionId - Optional. Auto-resolved if customer has exactly one active subscription.
     *
     * @returns Promise resolving to the released claims and updated usage
     *
     * @example
     * const { release } = useResource('seats')
     *
     * // Release anonymous claims (FIFO)
     * await release({ quantity: 2 })
     *
     * // Release by external ID
     * await release({ externalId: 'user_123' })
     */
    release: (params: Omit<ReleaseResourceParams, 'resourceSlug'>) => Promise<{
        releasedClaims: ResourceClaim[];
        usage: ResourceUsage;
    }>;
}
/**
 * Hook to access a specific resource by slug.
 *
 * This is a convenience wrapper around `useResources()` that:
 * - Filters to the specific resource by slug
 * - Fetches claims for this specific resource
 * - Pre-binds `resourceSlug` to claim/release functions
 *
 * Both hooks share the same underlying query cache, so multiple
 * `useResource()` calls don't result in duplicate fetches.
 *
 * Must be used within a `FlowgladProvider`.
 *
 * @param resourceSlug - The resource type to access (e.g., 'seats', 'api_keys')
 *
 * @returns Object containing resource usage, claims array, loading state, error, and mutation functions
 *
 * @example
 * function SeatManager() {
 *   const { usage, claims, claim, release, isLoading } = useResource('seats')
 *
 *   if (isLoading) return <Spinner />
 *
 *   return (
 *     <div>
 *       <p>{usage?.claimed} / {usage?.capacity} seats used</p>
 *
 *       <h3>Active Claims</h3>
 *       <ul>
 *         {claims.map(c => (
 *           <li key={c.id}>
 *             {c.externalId ?? 'Anonymous'} - claimed at {new Date(c.claimedAt).toLocaleString()}
 *             <button onClick={() => release({ claimIds: [c.id] })}>Release</button>
 *           </li>
 *         ))}
 *       </ul>
 *
 *       <button
 *         onClick={() => claim({ quantity: 1 })}
 *         disabled={usage?.available === 0}
 *       >
 *         Add Seat
 *       </button>
 *     </div>
 *   )
 * }
 *
 * @example
 * // Named claim - assign seat to specific user
 * function AssignSeat({ userId }: { userId: string }) {
 *   const { claim, claims } = useResource('seats')
 *
 *   // Check if user already has a seat
 *   const userHasSeat = claims.some(c => c.externalId === userId)
 *
 *   const handleAssign = async () => {
 *     // Named claims are idempotent - safe to call multiple times
 *     await claim({ externalId: userId, metadata: { assignedAt: Date.now() } })
 *   }
 *
 *   return (
 *     <button onClick={handleAssign} disabled={userHasSeat}>
 *       {userHasSeat ? 'Seat Assigned' : 'Assign Seat'}
 *     </button>
 *   )
 * }
 */
export declare const useResource: (resourceSlug: string) => UseResourceResult;
