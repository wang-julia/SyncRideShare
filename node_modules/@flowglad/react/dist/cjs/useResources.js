"use strict";
"use client";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var useResources_exports = {};
__export(useResources_exports, {
  RESOURCES_QUERY_KEY: () => RESOURCES_QUERY_KEY,
  RESOURCE_CLAIMS_QUERY_KEY: () => RESOURCE_CLAIMS_QUERY_KEY,
  useResource: () => useResource,
  useResources: () => useResources
});
module.exports = __toCommonJS(useResources_exports);
var import_shared = require("@flowglad/shared");
var import_react_query = require("@tanstack/react-query");
var import_react = require("react");
var import_FlowgladConfigContext = require("./FlowgladConfigContext");
var import_FlowgladContext = require("./FlowgladContext");
const RESOURCES_QUERY_KEY = "flowglad-resources";
const RESOURCE_CLAIMS_QUERY_KEY = "flowglad-resource-claims";
const mockResources = [
  {
    resourceSlug: "seats",
    resourceId: "res_mock_seats",
    capacity: 10,
    claimed: 3,
    available: 7
  },
  {
    resourceSlug: "api_keys",
    resourceId: "res_mock_api_keys",
    capacity: 5,
    claimed: 2,
    available: 3
  }
];
const createMockClaim = (resourceSlug, externalId = null) => ({
  id: `claim_mock_${Date.now()}`,
  subscriptionItemFeatureId: "sif_mock",
  resourceId: `res_mock_${resourceSlug}`,
  subscriptionId: "sub_mock",
  pricingModelId: "pm_mock",
  externalId,
  claimedAt: Date.now(),
  releasedAt: null,
  releaseReason: null,
  metadata: null,
  createdAt: Date.now(),
  updatedAt: Date.now(),
  livemode: false,
  organizationId: "org_mock"
});
const useResources = () => {
  const { baseURL, betterAuthBasePath, requestConfig, __devMode } = (0, import_FlowgladConfigContext.useFlowgladConfig)();
  const queryClient = (0, import_react_query.useQueryClient)();
  const {
    data: resources,
    isLoading,
    error
  } = (0, import_react_query.useQuery)({
    queryKey: [RESOURCES_QUERY_KEY],
    queryFn: () => __async(null, null, function* () {
      var _a;
      if (__devMode) {
        return mockResources;
      }
      const flowgladRoute = (0, import_FlowgladContext.getFlowgladRoute)(
        baseURL,
        betterAuthBasePath
      );
      const response = yield fetch(
        `${flowgladRoute}/${import_shared.FlowgladActionKey.GetResourceUsages}`,
        __spreadValues({
          // Better Auth endpoints are POST-only (they proxy internally to the correct action method),
          // while the standalone route handler uses the action's declared method (GET here).
          method: betterAuthBasePath ? "POST" : import_shared.flowgladActionValidators[import_shared.FlowgladActionKey.GetResourceUsages].method,
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, requestConfig == null ? void 0 : requestConfig.headers)
        }, betterAuthBasePath ? { body: JSON.stringify({}) } : {})
      );
      const json = yield response.json();
      if (json.error) {
        throw new Error(
          ((_a = json.error.json) == null ? void 0 : _a.message) || json.error.message || "Failed to fetch resources"
        );
      }
      return json.data.resources;
    })
  });
  const claimMutation = (0, import_react_query.useMutation)({
    mutationFn: (params) => __async(null, null, function* () {
      var _a, _b, _c, _d;
      if (__devMode) {
        const mockClaims = [];
        const quantity = (_a = params.quantity) != null ? _a : 1;
        const externalIds = (_b = params.externalIds) != null ? _b : params.externalId ? [params.externalId] : [];
        if (externalIds.length > 0) {
          for (const extId of externalIds) {
            mockClaims.push(
              createMockClaim(params.resourceSlug, extId)
            );
          }
        } else {
          for (let i = 0; i < quantity; i++) {
            mockClaims.push(
              createMockClaim(params.resourceSlug, null)
            );
          }
        }
        const mockResource = (_c = mockResources.find(
          (r) => r.resourceSlug === params.resourceSlug
        )) != null ? _c : mockResources[0];
        return {
          claims: mockClaims,
          usage: __spreadProps(__spreadValues({}, mockResource), {
            claimed: mockResource.claimed + mockClaims.length,
            available: mockResource.available - mockClaims.length
          })
        };
      }
      const flowgladRoute = (0, import_FlowgladContext.getFlowgladRoute)(
        baseURL,
        betterAuthBasePath
      );
      const response = yield fetch(
        `${flowgladRoute}/${import_shared.FlowgladActionKey.ClaimResource}`,
        {
          method: "POST",
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, requestConfig == null ? void 0 : requestConfig.headers),
          body: JSON.stringify(params)
        }
      );
      const json = yield response.json();
      if (json.error) {
        throw new Error(
          ((_d = json.error.json) == null ? void 0 : _d.message) || json.error.message || "Failed to claim resource"
        );
      }
      return json.data;
    }),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: [RESOURCES_QUERY_KEY]
      });
      queryClient.invalidateQueries({
        queryKey: [RESOURCE_CLAIMS_QUERY_KEY]
      });
    }
  });
  const releaseMutation = (0, import_react_query.useMutation)({
    mutationFn: (params) => __async(null, null, function* () {
      var _a, _b, _c;
      if (__devMode) {
        const mockReleasedClaims = [];
        const quantity = (_a = params.quantity) != null ? _a : 1;
        const now = Date.now();
        for (let i = 0; i < quantity; i++) {
          mockReleasedClaims.push(__spreadProps(__spreadValues({}, createMockClaim(params.resourceSlug, null)), {
            claimedAt: now - 1e4,
            // Claimed 10 seconds ago
            releasedAt: now
          }));
        }
        const mockResource = (_b = mockResources.find(
          (r) => r.resourceSlug === params.resourceSlug
        )) != null ? _b : mockResources[0];
        return {
          releasedClaims: mockReleasedClaims,
          usage: __spreadProps(__spreadValues({}, mockResource), {
            claimed: Math.max(
              0,
              mockResource.claimed - mockReleasedClaims.length
            ),
            available: Math.min(
              mockResource.capacity,
              mockResource.available + mockReleasedClaims.length
            )
          })
        };
      }
      const flowgladRoute = (0, import_FlowgladContext.getFlowgladRoute)(
        baseURL,
        betterAuthBasePath
      );
      const response = yield fetch(
        `${flowgladRoute}/${import_shared.FlowgladActionKey.ReleaseResource}`,
        {
          method: "POST",
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, requestConfig == null ? void 0 : requestConfig.headers),
          body: JSON.stringify(params)
        }
      );
      const json = yield response.json();
      if (json.error) {
        throw new Error(
          ((_c = json.error.json) == null ? void 0 : _c.message) || json.error.message || "Failed to release resource"
        );
      }
      return json.data;
    }),
    onSuccess: () => {
      queryClient.invalidateQueries({
        queryKey: [RESOURCES_QUERY_KEY]
      });
      queryClient.invalidateQueries({
        queryKey: [RESOURCE_CLAIMS_QUERY_KEY]
      });
    }
  });
  return {
    resources,
    isLoading,
    error: error != null ? error : null,
    claim: claimMutation.mutateAsync,
    release: releaseMutation.mutateAsync
  };
};
const useResource = (resourceSlug) => {
  var _a;
  const { baseURL, betterAuthBasePath, requestConfig, __devMode } = (0, import_FlowgladConfigContext.useFlowgladConfig)();
  const {
    resources,
    isLoading,
    error,
    claim: claimAll,
    release: releaseAll
  } = useResources();
  const {
    data: claims,
    isLoading: isLoadingClaims,
    error: claimsError
  } = (0, import_react_query.useQuery)({
    queryKey: [RESOURCE_CLAIMS_QUERY_KEY, resourceSlug],
    queryFn: () => __async(null, null, function* () {
      var _a2;
      if (__devMode) {
        return [
          createMockClaim(resourceSlug, "user_mock_1"),
          createMockClaim(resourceSlug, null)
        ];
      }
      const flowgladRoute = (0, import_FlowgladContext.getFlowgladRoute)(
        baseURL,
        betterAuthBasePath
      );
      const response = yield fetch(
        `${flowgladRoute}/${import_shared.FlowgladActionKey.ListResourceClaims}`,
        {
          method: "POST",
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, requestConfig == null ? void 0 : requestConfig.headers),
          body: JSON.stringify({ resourceSlug })
        }
      );
      const json = yield response.json();
      if (json.error) {
        throw new Error(
          ((_a2 = json.error.json) == null ? void 0 : _a2.message) || json.error.message || "Failed to fetch resource claims"
        );
      }
      return json.data.claims;
    })
  });
  const usage = resources == null ? void 0 : resources.find(
    (r) => r.resourceSlug === resourceSlug
  );
  const claim = (0, import_react.useCallback)(
    (params) => __async(null, null, function* () {
      return claimAll(__spreadProps(__spreadValues({}, params), {
        resourceSlug
      }));
    }),
    [claimAll, resourceSlug]
  );
  const release = (0, import_react.useCallback)(
    (params) => __async(null, null, function* () {
      return releaseAll(__spreadProps(__spreadValues({}, params), {
        resourceSlug
      }));
    }),
    [releaseAll, resourceSlug]
  );
  const combinedError = (_a = error != null ? error : claimsError) != null ? _a : null;
  return {
    usage,
    claims: claims != null ? claims : [],
    // Always return an array, never undefined
    isLoading,
    isLoadingClaims,
    error: combinedError,
    claim,
    release
  };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  RESOURCES_QUERY_KEY,
  RESOURCE_CLAIMS_QUERY_KEY,
  useResource,
  useResources
});
//# sourceMappingURL=useResources.js.map