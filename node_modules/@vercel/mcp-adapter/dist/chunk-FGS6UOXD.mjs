import { __objRest, __async, __spreadProps, __spreadValues } from './chunk-FF57VHLH.mjs';
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js';
import { SSEServerTransport } from '@modelcontextprotocol/sdk/server/sse.js';
import { ServerResponse, IncomingMessage } from 'http';
import { createClient } from 'redis';
import { Socket } from 'net';
import { Readable } from 'stream';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import assert from 'assert';
import { AsyncLocalStorage } from 'async_hooks';
import { EventEmitter } from 'events';

// src/lib/log-helper.ts
function createEvent(event) {
  return __spreadProps(__spreadValues({}, event), {
    timestamp: Date.now()
  });
}

// src/lib/event-emitter.ts
var EventEmittingResponse = class extends ServerResponse {
  constructor(req, onEvent, sessionId) {
    super(req);
    this.onEvent = onEvent;
    this.sessionId = sessionId;
    this.requestId = crypto.randomUUID();
    this.startTime = Date.now();
  }
  emitEvent(event) {
    if (this.onEvent) {
      this.onEvent(
        createEvent(__spreadProps(__spreadValues({}, event), {
          sessionId: this.sessionId,
          requestId: this.requestId
        }))
      );
    }
  }
  startSession(transport, clientInfo) {
    this.emitEvent({
      type: "SESSION_STARTED",
      transport,
      clientInfo
    });
  }
  endSession(transport) {
    this.emitEvent({
      type: "SESSION_ENDED",
      transport
    });
  }
  requestReceived(method, parameters) {
    this.emitEvent({
      type: "REQUEST_RECEIVED",
      method,
      parameters,
      status: "success"
    });
  }
  requestCompleted(method, result, error) {
    this.emitEvent({
      type: "REQUEST_COMPLETED",
      method,
      result,
      duration: Date.now() - this.startTime,
      status: error ? "error" : "success"
    });
    if (error) {
      this.error(error, `Error executing request ${method}`, "request");
    }
  }
  error(error, context, source = "system", severity = "error") {
    this.emitEvent({
      type: "ERROR",
      error,
      context,
      source,
      severity
    });
  }
  end(chunk, encoding, cb) {
    let finalChunk = chunk;
    let finalEncoding = encoding;
    let finalCallback = cb;
    if (typeof chunk === "function") {
      finalCallback = chunk;
      finalChunk = void 0;
      finalEncoding = void 0;
    } else if (typeof encoding === "function") {
      finalCallback = encoding;
      finalEncoding = void 0;
    }
    return super.end(
      finalChunk,
      finalEncoding,
      finalCallback
    );
  }
};
var authContext = new AsyncLocalStorage();
function getAuthContext() {
  return authContext.getStore();
}
function withAuthContext(authInfo, callback) {
  return authContext.run(authInfo, callback);
}

// src/next/mcp-api-handler.ts
function createLogger(verboseLogs = false) {
  return {
    log: (...args) => {
      if (verboseLogs)
        console.log(...args);
    },
    error: (...args) => {
      if (verboseLogs)
        console.error(...args);
    },
    warn: (...args) => {
      if (verboseLogs)
        console.warn(...args);
    },
    info: (...args) => {
      if (verboseLogs)
        console.info(...args);
    },
    debug: (...args) => {
      if (verboseLogs)
        console.debug(...args);
    }
  };
}
function deriveEndpointsFromBasePath(basePath) {
  const normalizedBasePath = basePath.replace(/\/$/, "");
  return {
    streamableHttpEndpoint: `${normalizedBasePath}/mcp`,
    sseEndpoint: `${normalizedBasePath}/sse`,
    sseMessageEndpoint: `${normalizedBasePath}/message`
  };
}
function calculateEndpoints({
  basePath,
  streamableHttpEndpoint = "/mcp",
  sseEndpoint = "/sse",
  sseMessageEndpoint = "/message"
}) {
  const {
    streamableHttpEndpoint: fullStreamableHttpEndpoint,
    sseEndpoint: fullSseEndpoint,
    sseMessageEndpoint: fullSseMessageEndpoint
  } = basePath != null ? deriveEndpointsFromBasePath(basePath) : {
    streamableHttpEndpoint,
    sseEndpoint,
    sseMessageEndpoint
  };
  return {
    streamableHttpEndpoint: fullStreamableHttpEndpoint,
    sseEndpoint: fullSseEndpoint,
    sseMessageEndpoint: fullSseMessageEndpoint
  };
}
var redisPublisher;
var redis;
function initializeRedis(_0) {
  return __async(this, arguments, function* ({
    redisUrl,
    logger
  }) {
    if (redis && redisPublisher) {
      return { redis, redisPublisher };
    }
    if (!redisUrl) {
      throw new Error("redisUrl is required");
    }
    redis = createClient({
      url: redisUrl
    });
    redisPublisher = createClient({
      url: redisUrl
    });
    redis.on("error", (err) => {
      logger.error("Redis error", err);
    });
    redisPublisher.on("error", (err) => {
      logger.error("Redis error", err);
    });
    yield Promise.all([redis.connect(), redisPublisher.connect()]);
    return { redis, redisPublisher };
  });
}
function initializeMcpApiHandler(initializeServer, serverOptions = {}, config = {
  redisUrl: process.env.REDIS_URL || process.env.KV_URL,
  streamableHttpEndpoint: "/mcp",
  sseEndpoint: "/sse",
  sseMessageEndpoint: "/message",
  basePath: "",
  maxDuration: 60,
  verboseLogs: false,
  disableSse: false
}) {
  const {
    redisUrl,
    basePath,
    streamableHttpEndpoint: explicitStreamableHttpEndpoint,
    sseEndpoint: explicitSseEndpoint,
    sseMessageEndpoint: explicitSseMessageEndpoint,
    maxDuration,
    verboseLogs,
    disableSse
  } = config;
  const _a = serverOptions, {
    serverInfo = {
      name: "mcp-typescript server on vercel",
      version: "0.1.0"
    }
  } = _a, mcpServerOptions = __objRest(_a, [
    "serverInfo"
  ]);
  const { streamableHttpEndpoint, sseEndpoint, sseMessageEndpoint } = calculateEndpoints({
    basePath,
    streamableHttpEndpoint: explicitStreamableHttpEndpoint,
    sseEndpoint: explicitSseEndpoint,
    sseMessageEndpoint: explicitSseMessageEndpoint
  });
  const logger = createLogger(verboseLogs);
  let servers = [];
  let statelessServer;
  const statelessTransport = new StreamableHTTPServerTransport({
    sessionIdGenerator: void 0
  });
  return function mcpApiHandler(req, res) {
    return __async(this, null, function* () {
      var _a2, _b, _c;
      const url = new URL(req.url || "", "https://example.com");
      if (url.pathname === streamableHttpEndpoint) {
        if (req.method === "GET") {
          logger.log("Received GET MCP request");
          res.writeHead(405).end(
            JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: "Method not allowed."
              },
              id: null
            })
          );
          return;
        }
        if (req.method === "DELETE") {
          logger.log("Received DELETE MCP request");
          res.writeHead(405).end(
            JSON.stringify({
              jsonrpc: "2.0",
              error: {
                code: -32e3,
                message: "Method not allowed."
              },
              id: null
            })
          );
          return;
        }
        if (req.method === "POST") {
          const eventRes = new EventEmittingResponse(
            createFakeIncomingMessage(),
            config.onEvent
          );
          if (!statelessServer) {
            statelessServer = new McpServer(serverInfo, mcpServerOptions);
            yield initializeServer(statelessServer);
            yield statelessServer.connect(statelessTransport);
          }
          let bodyContent;
          const contentType = req.headers.get("content-type") || "";
          if (contentType.includes("application/json")) {
            bodyContent = yield req.json();
          } else {
            bodyContent = yield req.text();
          }
          const incomingRequest = createFakeIncomingMessage({
            method: req.method,
            url: req.url,
            headers: Object.fromEntries(req.headers),
            body: bodyContent,
            auth: req.auth
            // Use the auth info that should already be set by withMcpAuth
          });
          const wrappedRes = new EventEmittingResponse(
            incomingRequest,
            config.onEvent
          );
          Object.assign(wrappedRes, res);
          try {
            yield statelessTransport.handleRequest(incomingRequest, wrappedRes);
            if (typeof bodyContent === "object" && bodyContent && "method" in bodyContent) {
              eventRes.requestCompleted(
                bodyContent.method,
                bodyContent
              );
            }
          } catch (error) {
            if (typeof bodyContent === "object" && bodyContent && "method" in bodyContent) {
              eventRes.requestCompleted(
                bodyContent.method,
                void 0,
                error instanceof Error ? error : String(error)
              );
            }
            throw error;
          }
        }
      } else if (url.pathname === sseEndpoint) {
        let logInContext2 = function(severity, ...messages) {
          logs.push({
            type: severity,
            messages
          });
        };
        if (disableSse) {
          res.statusCode = 404;
          res.end("Not found");
          return;
        }
        if (req.method !== "GET") {
          logger.log(`Rejected SSE connection with method ${req.method}`);
          res.writeHead(405, { "Content-Type": "text/plain" }).end("Method Not Allowed");
          return;
        }
        const acceptHeader = req.headers.get("accept") || req.headers.get("Accept");
        if (acceptHeader && !acceptHeader.includes("text/event-stream") && !acceptHeader.includes("*/*") && !acceptHeader.includes("text/*")) {
          logger.log(
            `Rejected SSE connection with incompatible Accept header: ${acceptHeader}`
          );
          res.writeHead(406, { "Content-Type": "text/plain" }).end("Not Acceptable");
          return;
        }
        const { redis: redis2, redisPublisher: redisPublisher2 } = yield initializeRedis({
          redisUrl,
          logger
        });
        logger.log("Got new SSE connection");
        assert(sseMessageEndpoint, "sseMessageEndpoint is required");
        const transport = new SSEServerTransport(sseMessageEndpoint, res);
        const sessionId = transport.sessionId;
        const eventRes = new EventEmittingResponse(
          createFakeIncomingMessage(),
          config.onEvent,
          sessionId
        );
        eventRes.startSession("SSE", {
          userAgent: (_a2 = req.headers.get("user-agent")) != null ? _a2 : void 0,
          ip: (_c = (_b = req.headers.get("x-forwarded-for")) != null ? _b : req.headers.get("x-real-ip")) != null ? _c : void 0
        });
        const server = new McpServer(serverInfo, serverOptions);
        yield initializeServer(server);
        servers.push(server);
        server.server.onclose = () => {
          logger.log("SSE connection closed");
          eventRes.endSession("SSE");
          servers = servers.filter((s) => s !== server);
        };
        let logs = [];
        const handleMessage = (message) => __async(this, null, function* () {
          logger.log("Received message from Redis", message);
          logInContext2("log", "Received message from Redis", message);
          const request = JSON.parse(message);
          const req2 = createFakeIncomingMessage({
            method: request.method,
            url: request.url,
            headers: request.headers,
            body: request.body
          });
          const syntheticRes = new EventEmittingResponse(
            req2,
            config.onEvent,
            sessionId
          );
          let status = 100;
          let body = "";
          syntheticRes.writeHead = (statusCode) => {
            status = statusCode;
            return syntheticRes;
          };
          syntheticRes.end = (b) => {
            body = b;
            return syntheticRes;
          };
          try {
            yield transport.handlePostMessage(req2, syntheticRes);
            if (typeof request.body === "object" && request.body && "method" in request.body) {
              try {
                const result = JSON.parse(body);
                eventRes.requestCompleted(request.body.method, result);
              } catch (e) {
                eventRes.requestCompleted(request.body.method, body);
              }
            }
          } catch (error) {
            eventRes.error(
              error instanceof Error ? error : String(error),
              "Error handling SSE message",
              "session"
            );
            throw error;
          }
          yield redisPublisher2.publish(
            `responses:${sessionId}:${request.requestId}`,
            JSON.stringify({
              status,
              body
            })
          );
          if (status >= 200 && status < 300) {
            logInContext2(
              "log",
              `Request ${sessionId}:${request.requestId} succeeded: ${body}`
            );
          } else {
            logInContext2(
              "error",
              `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`
            );
            eventRes.error(
              `Request failed with status ${status}`,
              body,
              "session"
            );
          }
        });
        const interval = setInterval(() => {
          for (const log of logs) {
            logger[log.type](...log.messages);
          }
          logs = [];
        }, 100);
        yield redis2.subscribe(`requests:${sessionId}`, handleMessage);
        logger.log(`Subscribed to requests:${sessionId}`);
        let timeout;
        let resolveTimeout;
        const waitPromise = new Promise((resolve) => {
          resolveTimeout = resolve;
          timeout = setTimeout(() => {
            resolve("max duration reached");
          }, (maxDuration != null ? maxDuration : 60) * 1e3);
        });
        function cleanup() {
          return __async(this, null, function* () {
            clearTimeout(timeout);
            clearInterval(interval);
            yield redis2.unsubscribe(`requests:${sessionId}`, handleMessage);
            logger.log("Done");
            res.statusCode = 200;
            res.end();
          });
        }
        req.signal.addEventListener(
          "abort",
          () => resolveTimeout("client hang up")
        );
        yield server.connect(transport);
        const closeReason = yield waitPromise;
        logger.log(closeReason);
        yield cleanup();
      } else if (url.pathname === sseMessageEndpoint) {
        if (disableSse) {
          res.statusCode = 404;
          res.end("Not found");
          return;
        }
        const { redis: redis2, redisPublisher: redisPublisher2 } = yield initializeRedis({
          redisUrl,
          logger
        });
        logger.log("Received message");
        const body = yield req.text();
        let parsedBody;
        try {
          parsedBody = JSON.parse(body);
        } catch (e) {
          parsedBody = body;
        }
        const sessionId = url.searchParams.get("sessionId") || "";
        if (!sessionId) {
          res.statusCode = 400;
          res.end("No sessionId provided");
          return;
        }
        const requestId = crypto.randomUUID();
        const serializedRequest = {
          requestId,
          url: req.url || "",
          method: req.method || "",
          body: parsedBody,
          headers: Object.fromEntries(req.headers.entries())
        };
        let timeout;
        let hasResponded = false;
        const sendResponse = (status, body2) => {
          if (!hasResponded) {
            hasResponded = true;
            clearTimeout(timeout);
            res.statusCode = status;
            res.end(body2);
          }
        };
        yield redis2.subscribe(
          `responses:${sessionId}:${requestId}`,
          (message) => {
            try {
              const response = JSON.parse(message);
              sendResponse(response.status, response.body);
            } catch (error) {
              logger.error("Failed to parse response message:", error);
              sendResponse(500, "Internal server error");
            }
          }
        );
        yield redisPublisher2.publish(
          `requests:${sessionId}`,
          JSON.stringify(serializedRequest)
        );
        logger.log(`Published requests:${sessionId}`, serializedRequest);
        timeout = setTimeout(() => __async(this, null, function* () {
          yield redis2.unsubscribe(`responses:${sessionId}:${requestId}`);
          sendResponse(408, "Request timed out");
        }), 10 * 1e3);
        res.on("close", () => __async(this, null, function* () {
          hasResponded = true;
          clearTimeout(timeout);
          yield redis2.unsubscribe(`responses:${sessionId}:${requestId}`);
        }));
      } else {
        res.statusCode = 404;
        res.end("Not found");
      }
    });
  };
}
function createFakeIncomingMessage(options = {}) {
  const {
    method = "GET",
    url = "/",
    headers = {},
    body = null,
    socket = new Socket()
  } = options;
  const readable = new Readable();
  readable._read = () => {
  };
  if (body) {
    if (typeof body === "string") {
      readable.push(body);
    } else if (Buffer.isBuffer(body)) {
      readable.push(body);
    } else {
      const bodyString = JSON.stringify(body);
      readable.push(bodyString);
    }
    readable.push(null);
  } else {
    readable.push(null);
  }
  const req = new IncomingMessage(socket);
  req.method = method;
  req.url = url;
  req.headers = headers;
  const auth = options.auth || getAuthContext();
  if (auth) {
    req.auth = auth;
  }
  req.push = readable.push.bind(readable);
  req.read = readable.read.bind(readable);
  req.on = readable.on.bind(readable);
  req.pipe = readable.pipe.bind(readable);
  return req;
}
function createServerResponseAdapter(signal, fn) {
  let writeHeadResolver;
  const writeHeadPromise = new Promise((resolve) => {
    writeHeadResolver = resolve;
  });
  return new Promise((resolve) => {
    let controller;
    let shouldClose = false;
    let wroteHead = false;
    let statusCode = 200;
    let headers;
    const writeHead = (code, headersArg) => {
      if (typeof headersArg === "string") {
        throw new Error("Status message of writeHead not supported");
      }
      statusCode = code;
      headers = headersArg;
      wroteHead = true;
      writeHeadResolver({
        statusCode,
        headers
      });
      return fakeServerResponse;
    };
    const bufferedData = [];
    const write = (chunk, encoding) => {
      if (encoding) {
        throw new Error("Encoding not supported");
      }
      if (chunk instanceof Buffer) {
        throw new Error("Buffer not supported");
      }
      if (!wroteHead) {
        writeHead(statusCode, headers);
      }
      if (!controller) {
        bufferedData.push(new TextEncoder().encode(chunk));
        return true;
      }
      controller.enqueue(new TextEncoder().encode(chunk));
      return true;
    };
    const eventEmitter = new EventEmitter();
    const fakeServerResponse = {
      writeHead,
      write,
      end: (data) => {
        if (data) {
          write(data);
        }
        if (!controller) {
          shouldClose = true;
          return fakeServerResponse;
        }
        try {
          controller.close();
        } catch (e) {
        }
        return fakeServerResponse;
      },
      on: (event, listener) => {
        eventEmitter.on(event, listener);
        return fakeServerResponse;
      },
      get statusCode() {
        return statusCode;
      },
      set statusCode(code) {
        statusCode = code;
        if (wroteHead) {
          writeHeadResolver({
            statusCode,
            headers
          });
        }
      }
    };
    signal.addEventListener("abort", () => {
      eventEmitter.emit("close");
    });
    void fn(fakeServerResponse);
    void (() => __async(this, null, function* () {
      const head = yield writeHeadPromise;
      const response = new Response(
        new ReadableStream({
          start(c) {
            controller = c;
            for (const chunk of bufferedData) {
              controller.enqueue(chunk);
            }
            if (shouldClose) {
              controller.close();
            }
          }
        }),
        {
          status: head.statusCode,
          headers: head.headers
        }
      );
      resolve(response);
    }))();
  });
}

// src/next/index.ts
function createMcpRouteHandler(initializeServer, serverOptions, config) {
  const mcpHandler = initializeMcpApiHandler(
    initializeServer,
    serverOptions,
    config
  );
  return (request) => {
    return createServerResponseAdapter(request.signal, (res) => {
      mcpHandler(request, res);
    });
  };
}

export { createMcpRouteHandler, withAuthContext };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=chunk-FGS6UOXD.mjs.map