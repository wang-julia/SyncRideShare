{"version":3,"sources":["../src/next/mcp-api-handler.ts","../src/lib/event-emitter.ts","../src/lib/log-helper.ts","../src/next/auth-context.ts","../src/next/server-response-adapter.ts","../src/next/index.ts"],"names":["_a","logInContext","redis","redisPublisher","req","body"],"mappings":"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","sourcesContent":["import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\nimport { SSEServerTransport } from \"@modelcontextprotocol/sdk/server/sse.js\";\nimport {\n  type IncomingHttpHeaders,\n  IncomingMessage,\n  type ServerResponse,\n} from \"node:http\";\nimport { createClient } from \"redis\";\nimport { Socket } from \"node:net\";\nimport { Readable } from \"node:stream\";\nimport { StreamableHTTPServerTransport } from \"@modelcontextprotocol/sdk/server/streamableHttp.js\";\nimport type { BodyType } from \"./server-response-adapter\";\nimport assert from \"node:assert\";\nimport type {\n  McpEvent,\n  McpErrorEvent,\n  McpSessionEvent,\n  McpRequestEvent,\n} from \"../lib/log-helper\";\nimport { createEvent } from \"../lib/log-helper\";\nimport { EventEmittingResponse } from \"../lib/event-emitter.js\";\nimport { AuthInfo } from \"@modelcontextprotocol/sdk/server/auth/types\";\nimport { getAuthContext } from \"./auth-context\";\nimport { ServerOptions } from \".\";\n\ninterface SerializedRequest {\n  requestId: string;\n  url: string;\n  method: string;\n  body: BodyType;\n  headers: IncomingHttpHeaders;\n}\n\ntype LogLevel = \"log\" | \"error\" | \"warn\" | \"info\" | \"debug\";\n\ntype Logger = {\n  log: (...args: unknown[]) => void;\n  error: (...args: unknown[]) => void;\n  warn: (...args: unknown[]) => void;\n  info: (...args: unknown[]) => void;\n  debug: (...args: unknown[]) => void;\n};\n\nfunction createLogger(verboseLogs = false): Logger {\n  return {\n    log: (...args: unknown[]) => {\n      if (verboseLogs) console.log(...args);\n    },\n    error: (...args: unknown[]) => {\n      if (verboseLogs) console.error(...args);\n    },\n    warn: (...args: unknown[]) => {\n      if (verboseLogs) console.warn(...args);\n    },\n    info: (...args: unknown[]) => {\n      if (verboseLogs) console.info(...args);\n    },\n    debug: (...args: unknown[]) => {\n      if (verboseLogs) console.debug(...args);\n    },\n  };\n}\n/**\n * Configuration for the MCP handler.\n * @property redisUrl - The URL of the Redis instance to use for the MCP handler.\n * @property streamableHttpEndpoint - The endpoint to use for the streamable HTTP transport.\n * @property sseEndpoint - The endpoint to use for the SSE transport.\n * @property verboseLogs - If true, enables console logging.\n */\nexport type Config = {\n  /**\n   * The URL of the Redis instance to use for the MCP handler.\n   * @default process.env.REDIS_URL || process.env.KV_URL\n   */\n  redisUrl?: string;\n  /**\n   * The endpoint to use for the streamable HTTP transport.\n   * @deprecated Use `set basePath` instead.\n   * @default \"/mcp\"\n   */\n  streamableHttpEndpoint?: string;\n  /**\n   * The endpoint to use for the SSE transport.\n   * @deprecated Use `set basePath` instead.\n   * @default \"/sse\"\n   */\n  sseEndpoint?: string;\n  /**\n   * The endpoint to use for the SSE messages transport.\n   * @deprecated Use `set basePath` instead.\n   * @default \"/message\"\n   */\n  sseMessageEndpoint?: string;\n  /**\n   * The maximum duration of an MCP request in seconds.\n   * @default 60\n   */\n  maxDuration?: number;\n  /**\n   * If true, enables console logging.\n   * @default false\n   */\n  verboseLogs?: boolean;\n  /**\n   * The base path to use for deriving endpoints.\n   * If provided, endpoints will be derived from this path.\n   * For example, if basePath is \"/\", that means your routing is:\n   *  /app/[transport]/route.ts and then:\n   * - streamableHttpEndpoint will be \"/mcp\"\n   * - sseEndpoint will be \"/sse\"\n   * - sseMessageEndpoint will be \"/message\"\n   * @default \"\"\n   */\n  basePath?: string;\n  /**\n   * Callback function that receives MCP events.\n   * This can be used to track analytics, debug issues, or implement custom behaviors.\n   */\n  onEvent?: (event: McpEvent) => void;\n\n  /**\n   * If true, disables the SSE endpoint.\n   * As of 2025-03-26, SSE is not supported by the MCP spec.\n   * https://modelcontextprotocol.io/specification/2025-03-26/basic/transports\n   * @default false\n   */\n  disableSse?: boolean;\n};\n\n/**\n * Derives MCP endpoints from a base path.\n * @param basePath - The base path to derive endpoints from\n * @returns An object containing the derived endpoints\n */\nfunction deriveEndpointsFromBasePath(basePath: string): {\n  streamableHttpEndpoint: string;\n  sseEndpoint: string;\n  sseMessageEndpoint: string;\n} {\n  // Remove trailing slash if present\n  const normalizedBasePath = basePath.replace(/\\/$/, \"\");\n\n  return {\n    streamableHttpEndpoint: `${normalizedBasePath}/mcp`,\n    sseEndpoint: `${normalizedBasePath}/sse`,\n    sseMessageEndpoint: `${normalizedBasePath}/message`,\n  };\n}\n/**\n * Calculates the endpoints for the MCP handler.\n * @param config - The configuration for the MCP handler.\n * @returns An object containing the endpoints for the MCP handler.\n */\nexport function calculateEndpoints({\n  basePath,\n  streamableHttpEndpoint = \"/mcp\",\n  sseEndpoint = \"/sse\",\n  sseMessageEndpoint = \"/message\",\n}: Config) {\n  const {\n    streamableHttpEndpoint: fullStreamableHttpEndpoint,\n    sseEndpoint: fullSseEndpoint,\n    sseMessageEndpoint: fullSseMessageEndpoint,\n  } = basePath != null\n    ? deriveEndpointsFromBasePath(basePath)\n    : {\n        streamableHttpEndpoint,\n        sseEndpoint,\n        sseMessageEndpoint,\n      };\n\n  return {\n    streamableHttpEndpoint: fullStreamableHttpEndpoint,\n    sseEndpoint: fullSseEndpoint,\n    sseMessageEndpoint: fullSseMessageEndpoint,\n  };\n}\n\nlet redisPublisher: ReturnType<typeof createClient>;\nlet redis: ReturnType<typeof createClient>;\n\nasync function initializeRedis({\n  redisUrl,\n  logger,\n}: {\n  redisUrl?: string;\n  logger: Logger;\n}) {\n  if (redis && redisPublisher) {\n    return { redis, redisPublisher };\n  }\n\n  if (!redisUrl) {\n    throw new Error(\"redisUrl is required\");\n  }\n\n  redis = createClient({\n    url: redisUrl,\n  });\n  redisPublisher = createClient({\n    url: redisUrl,\n  });\n  redis.on(\"error\", (err) => {\n    logger.error(\"Redis error\", err);\n  });\n  redisPublisher.on(\"error\", (err) => {\n    logger.error(\"Redis error\", err);\n  });\n\n  await Promise.all([redis.connect(), redisPublisher.connect()]);\n\n  return { redis, redisPublisher };\n}\n\nexport function initializeMcpApiHandler(\n  initializeServer:\n    | ((server: McpServer) => Promise<void>)\n    | ((server: McpServer) => void),\n  serverOptions: ServerOptions = {},\n  config: Config = {\n    redisUrl: process.env.REDIS_URL || process.env.KV_URL,\n    streamableHttpEndpoint: \"/mcp\",\n    sseEndpoint: \"/sse\",\n    sseMessageEndpoint: \"/message\",\n    basePath: \"\",\n    maxDuration: 60,\n    verboseLogs: false,\n    disableSse: false,\n  }\n) {\n  const {\n    redisUrl,\n    basePath,\n    streamableHttpEndpoint: explicitStreamableHttpEndpoint,\n    sseEndpoint: explicitSseEndpoint,\n    sseMessageEndpoint: explicitSseMessageEndpoint,\n    maxDuration,\n    verboseLogs,\n    disableSse,\n  } = config;\n\n  const {\n    serverInfo = {\n      name: \"mcp-typescript server on vercel\",\n      version: \"0.1.0\",\n    },\n    ...mcpServerOptions\n  } = serverOptions;\n\n  // If basePath is provided, derive endpoints from it\n  const { streamableHttpEndpoint, sseEndpoint, sseMessageEndpoint } =\n    calculateEndpoints({\n      basePath,\n      streamableHttpEndpoint: explicitStreamableHttpEndpoint,\n      sseEndpoint: explicitSseEndpoint,\n      sseMessageEndpoint: explicitSseMessageEndpoint,\n    });\n\n  const logger = createLogger(verboseLogs);\n\n  let servers: McpServer[] = [];\n\n  let statelessServer: McpServer;\n  const statelessTransport = new StreamableHTTPServerTransport({\n    sessionIdGenerator: undefined,\n  });\n\n  return async function mcpApiHandler(req: Request, res: ServerResponse) {\n    const url = new URL(req.url || \"\", \"https://example.com\");\n    if (url.pathname === streamableHttpEndpoint) {\n      if (req.method === \"GET\") {\n        logger.log(\"Received GET MCP request\");\n        res.writeHead(405).end(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: {\n              code: -32000,\n              message: \"Method not allowed.\",\n            },\n            id: null,\n          })\n        );\n        return;\n      }\n      if (req.method === \"DELETE\") {\n        logger.log(\"Received DELETE MCP request\");\n        res.writeHead(405).end(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            error: {\n              code: -32000,\n              message: \"Method not allowed.\",\n            },\n            id: null,\n          })\n        );\n        return;\n      }\n\n      if (req.method === \"POST\") {\n        const eventRes = new EventEmittingResponse(\n          createFakeIncomingMessage(),\n          config.onEvent\n        );\n\n        if (!statelessServer) {\n          statelessServer = new McpServer(serverInfo, mcpServerOptions);\n          await initializeServer(statelessServer);\n          await statelessServer.connect(statelessTransport);\n        }\n\n        // Parse the request body\n        let bodyContent: BodyType;\n        const contentType = req.headers.get(\"content-type\") || \"\";\n        if (contentType.includes(\"application/json\")) {\n          bodyContent = await req.json();\n        } else {\n          bodyContent = await req.text();\n        }\n\n        const incomingRequest = createFakeIncomingMessage({\n          method: req.method,\n          url: req.url,\n          headers: Object.fromEntries(req.headers),\n          body: bodyContent,\n          auth: req.auth, // Use the auth info that should already be set by withMcpAuth\n        });\n\n        // Create a response that will emit events\n        const wrappedRes = new EventEmittingResponse(\n          incomingRequest,\n          config.onEvent\n        );\n        Object.assign(wrappedRes, res);\n\n        try {\n          await statelessTransport.handleRequest(incomingRequest, wrappedRes);\n          if (\n            typeof bodyContent === \"object\" &&\n            bodyContent &&\n            \"method\" in bodyContent\n          ) {\n            eventRes.requestCompleted(\n              bodyContent.method as string,\n              bodyContent\n            );\n          }\n        } catch (error) {\n          if (\n            typeof bodyContent === \"object\" &&\n            bodyContent &&\n            \"method\" in bodyContent\n          ) {\n            eventRes.requestCompleted(\n              bodyContent.method as string,\n              undefined,\n              error instanceof Error ? error : String(error)\n            );\n          }\n          throw error;\n        }\n      }\n    } else if (url.pathname === sseEndpoint) {\n      if (disableSse) {\n        res.statusCode = 404;\n        res.end(\"Not found\");\n        return;\n      }\n\n      // Check HTTP method - only allow GET for SSE connections\n      if (req.method !== \"GET\") {\n        logger.log(`Rejected SSE connection with method ${req.method}`);\n        res\n          .writeHead(405, { \"Content-Type\": \"text/plain\" })\n          .end(\"Method Not Allowed\");\n        return;\n      }\n\n      // Check that Accept header supports event-stream\n      const acceptHeader =\n        req.headers.get(\"accept\") || req.headers.get(\"Accept\");\n      if (\n        acceptHeader &&\n        !acceptHeader.includes(\"text/event-stream\") &&\n        !acceptHeader.includes(\"*/*\") &&\n        !acceptHeader.includes(\"text/*\")\n      ) {\n        logger.log(\n          `Rejected SSE connection with incompatible Accept header: ${acceptHeader}`\n        );\n        res\n          .writeHead(406, { \"Content-Type\": \"text/plain\" })\n          .end(\"Not Acceptable\");\n        return;\n      }\n\n      const { redis, redisPublisher } = await initializeRedis({\n        redisUrl,\n        logger,\n      });\n      logger.log(\"Got new SSE connection\");\n      assert(sseMessageEndpoint, \"sseMessageEndpoint is required\");\n      const transport = new SSEServerTransport(sseMessageEndpoint, res);\n      const sessionId = transport.sessionId;\n\n      const eventRes = new EventEmittingResponse(\n        createFakeIncomingMessage(),\n        config.onEvent,\n        sessionId\n      );\n      eventRes.startSession(\"SSE\", {\n        userAgent: req.headers.get(\"user-agent\") ?? undefined,\n        ip:\n          req.headers.get(\"x-forwarded-for\") ??\n          req.headers.get(\"x-real-ip\") ??\n          undefined,\n      });\n\n      const server = new McpServer(serverInfo, serverOptions);\n      await initializeServer(server);\n\n      servers.push(server);\n\n      server.server.onclose = () => {\n        logger.log(\"SSE connection closed\");\n        eventRes.endSession(\"SSE\");\n        servers = servers.filter((s) => s !== server);\n      };\n\n      let logs: {\n        type: LogLevel;\n        messages: string[];\n      }[] = [];\n\n      // eslint-disable-next-line no-inner-declarations\n      function logInContext(severity: LogLevel, ...messages: string[]) {\n        logs.push({\n          type: severity,\n          messages,\n        });\n      }\n\n      // Handles messages originally received via /message\n      const handleMessage = async (message: string) => {\n        logger.log(\"Received message from Redis\", message);\n        logInContext(\"log\", \"Received message from Redis\", message);\n        const request = JSON.parse(message) as SerializedRequest;\n\n        // Make in IncomingMessage object because that is what the SDK expects.\n        const req = createFakeIncomingMessage({\n          method: request.method,\n          url: request.url,\n          headers: request.headers,\n          body: request.body,\n        });\n\n        const syntheticRes = new EventEmittingResponse(\n          req,\n          config.onEvent,\n          sessionId\n        );\n        let status = 100;\n        let body = \"\";\n        syntheticRes.writeHead = (statusCode: number) => {\n          status = statusCode;\n          return syntheticRes;\n        };\n        syntheticRes.end = (b: unknown) => {\n          body = b as string;\n          return syntheticRes;\n        };\n\n        try {\n          await transport.handlePostMessage(req, syntheticRes);\n\n          // If it was a function call, complete it\n          if (\n            typeof request.body === \"object\" &&\n            request.body &&\n            \"method\" in request.body\n          ) {\n            try {\n              const result = JSON.parse(body);\n              eventRes.requestCompleted(request.body.method as string, result);\n            } catch {\n              eventRes.requestCompleted(request.body.method as string, body);\n            }\n          }\n        } catch (error) {\n          eventRes.error(\n            error instanceof Error ? error : String(error),\n            \"Error handling SSE message\",\n            \"session\"\n          );\n          throw error;\n        }\n\n        await redisPublisher.publish(\n          `responses:${sessionId}:${request.requestId}`,\n          JSON.stringify({\n            status,\n            body,\n          })\n        );\n\n        if (status >= 200 && status < 300) {\n          logInContext(\n            \"log\",\n            `Request ${sessionId}:${request.requestId} succeeded: ${body}`\n          );\n        } else {\n          logInContext(\n            \"error\",\n            `Message for ${sessionId}:${request.requestId} failed with status ${status}: ${body}`\n          );\n          eventRes.error(\n            `Request failed with status ${status}`,\n            body,\n            \"session\"\n          );\n        }\n      };\n\n      const interval = setInterval(() => {\n        for (const log of logs) {\n          logger[log.type](...log.messages);\n        }\n        logs = [];\n      }, 100);\n\n      await redis.subscribe(`requests:${sessionId}`, handleMessage);\n      logger.log(`Subscribed to requests:${sessionId}`);\n\n      let timeout: NodeJS.Timeout;\n      let resolveTimeout: (value: unknown) => void;\n      const waitPromise = new Promise((resolve) => {\n        resolveTimeout = resolve;\n        timeout = setTimeout(() => {\n          resolve(\"max duration reached\");\n        }, (maxDuration ?? 60) * 1000);\n      });\n\n      // eslint-disable-next-line no-inner-declarations\n      async function cleanup() {\n        clearTimeout(timeout);\n        clearInterval(interval);\n        await redis.unsubscribe(`requests:${sessionId}`, handleMessage);\n        logger.log(\"Done\");\n        res.statusCode = 200;\n        res.end();\n      }\n      req.signal.addEventListener(\"abort\", () =>\n        resolveTimeout(\"client hang up\")\n      );\n\n      await server.connect(transport);\n      const closeReason = await waitPromise;\n      logger.log(closeReason);\n      await cleanup();\n    } else if (url.pathname === sseMessageEndpoint) {\n      if (disableSse) {\n        res.statusCode = 404;\n        res.end(\"Not found\");\n        return;\n      }\n\n      const { redis, redisPublisher } = await initializeRedis({\n        redisUrl,\n        logger,\n      });\n      logger.log(\"Received message\");\n\n      const body = await req.text();\n      let parsedBody: BodyType;\n      try {\n        parsedBody = JSON.parse(body);\n      } catch (e) {\n        parsedBody = body;\n      }\n\n      const sessionId = url.searchParams.get(\"sessionId\") || \"\";\n      if (!sessionId) {\n        res.statusCode = 400;\n        res.end(\"No sessionId provided\");\n        return;\n      }\n      const requestId = crypto.randomUUID();\n      const serializedRequest: SerializedRequest = {\n        requestId,\n        url: req.url || \"\",\n        method: req.method || \"\",\n        body: parsedBody,\n        headers: Object.fromEntries(req.headers.entries()),\n      };\n\n      // Declare timeout and response handling state before subscription\n      let timeout: NodeJS.Timeout;\n      let hasResponded = false;\n      // Safe response handler to prevent double res.end()\n      const sendResponse = (status: number, body: string) => {\n        if (!hasResponded) {\n          hasResponded = true;\n          clearTimeout(timeout);\n          res.statusCode = status;\n          res.end(body);\n        }\n      };\n\n      // Handles responses from the /sse endpoint.\n      await redis.subscribe(\n        `responses:${sessionId}:${requestId}`,\n        (message) => {\n          try {\n            const response = JSON.parse(message) as {\n              status: number;\n              body: string;\n            };\n            sendResponse(response.status, response.body);\n          } catch (error) {\n            logger.error(\"Failed to parse response message:\", error);\n            sendResponse(500, \"Internal server error\");\n          }\n        }\n      );\n\n      // Queue the request in Redis so that a subscriber can pick it up.\n      // One queue per session.\n      await redisPublisher.publish(\n        `requests:${sessionId}`,\n        JSON.stringify(serializedRequest)\n      );\n      logger.log(`Published requests:${sessionId}`, serializedRequest);\n\n      // Set timeout after subscription is established\n      timeout = setTimeout(async () => {\n        await redis.unsubscribe(`responses:${sessionId}:${requestId}`);\n        sendResponse(408, \"Request timed out\");\n      }, 10 * 1000);\n\n      res.on(\"close\", async () => {\n        hasResponded = true;\n        clearTimeout(timeout);\n        await redis.unsubscribe(`responses:${sessionId}:${requestId}`);\n      });\n    } else {\n      res.statusCode = 404;\n      res.end(\"Not found\");\n    }\n  };\n}\n\n// Define the options interface\ninterface FakeIncomingMessageOptions {\n  method?: string;\n  url?: string;\n  headers?: IncomingHttpHeaders;\n  body?: BodyType;\n  socket?: Socket;\n  auth?: AuthInfo;\n}\n\n// Create a fake IncomingMessage\nfunction createFakeIncomingMessage(\n  options: FakeIncomingMessageOptions = {}\n): IncomingMessage & { auth?: AuthInfo } {\n  const {\n    method = \"GET\",\n    url = \"/\",\n    headers = {},\n    body = null,\n    socket = new Socket(),\n  } = options;\n\n  // Create a readable stream that will be used as the base for IncomingMessage\n  const readable = new Readable();\n  readable._read = (): void => {}; // Required implementation\n\n  // Add the body content if provided\n  if (body) {\n    if (typeof body === \"string\") {\n      readable.push(body);\n    } else if (Buffer.isBuffer(body)) {\n      readable.push(body);\n    } else {\n      // Ensure proper JSON-RPC format\n      const bodyString = JSON.stringify(body);\n      readable.push(bodyString);\n    }\n    readable.push(null); // Signal the end of the stream\n  } else {\n    readable.push(null); // Always end the stream even if no body\n  }\n\n  // Create the IncomingMessage instance\n  const req = new IncomingMessage(socket) as IncomingMessage & {\n    auth?: AuthInfo;\n  };\n\n  // Set the properties\n  req.method = method;\n  req.url = url;\n  req.headers = headers;\n\n  const auth = options.auth || getAuthContext();\n  if (auth) {\n    // See https://github.com/modelcontextprotocol/typescript-sdk/blob/590d4841373fc4eb86ecc9079834353a98cb84a3/src/server/auth/middleware/bearerAuth.ts#L71 for more info.\n    (req as { auth?: AuthInfo }).auth = auth;\n  }\n\n  // Copy over the stream methods\n  req.push = readable.push.bind(readable);\n  req.read = readable.read.bind(readable);\n  // @ts-expect-error\n  req.on = readable.on.bind(readable);\n  req.pipe = readable.pipe.bind(readable);\n\n  return req;\n}\n","import { ServerResponse, type IncomingMessage } from \"node:http\";\nimport {\n  type McpErrorEvent,\n  type McpEvent,\n  type McpRequestEvent,\n  type McpSessionEvent,\n  createEvent,\n} from \"./log-helper\";\n\nexport class EventEmittingResponse extends ServerResponse {\n  private onEvent?: (event: McpEvent) => void;\n  private sessionId?: string;\n  private requestId: string;\n  private startTime: number;\n\n  constructor(\n    req: IncomingMessage,\n    onEvent?: (event: McpEvent) => void,\n    sessionId?: string\n  ) {\n    super(req);\n    this.onEvent = onEvent;\n    this.sessionId = sessionId;\n    this.requestId = crypto.randomUUID();\n    this.startTime = Date.now();\n  }\n\n  emitEvent(event: Omit<McpEvent, \"timestamp\" | \"sessionId\" | \"requestId\">) {\n    if (this.onEvent) {\n      this.onEvent(\n        createEvent({\n          ...event,\n          sessionId: this.sessionId,\n          requestId: this.requestId,\n        } as Omit<McpEvent, \"timestamp\">)\n      );\n    }\n  }\n\n  startSession(\n    transport: \"SSE\" | \"HTTP\",\n    clientInfo?: { userAgent?: string; ip?: string }\n  ) {\n    this.emitEvent({\n      type: \"SESSION_STARTED\",\n      transport,\n      clientInfo,\n    } as Omit<McpSessionEvent, \"timestamp\" | \"sessionId\" | \"requestId\">);\n  }\n\n  endSession(transport: \"SSE\" | \"HTTP\") {\n    this.emitEvent({\n      type: \"SESSION_ENDED\",\n      transport,\n    } as Omit<McpSessionEvent, \"timestamp\" | \"sessionId\" | \"requestId\">);\n  }\n\n  requestReceived(method: string, parameters?: unknown) {\n    this.emitEvent({\n      type: \"REQUEST_RECEIVED\",\n      method,\n      parameters,\n      status: \"success\",\n    } as Omit<McpRequestEvent, \"timestamp\" | \"sessionId\" | \"requestId\">);\n  }\n\n  requestCompleted(method: string, result?: unknown, error?: Error | string) {\n    this.emitEvent({\n      type: \"REQUEST_COMPLETED\",\n      method,\n      result,\n      duration: Date.now() - this.startTime,\n      status: error ? \"error\" : \"success\",\n    } as Omit<McpRequestEvent, \"timestamp\" | \"sessionId\" | \"requestId\">);\n\n    if (error) {\n      this.error(error, `Error executing request ${method}`, \"request\");\n    }\n  }\n\n  error(\n    error: Error | string,\n    context?: string,\n    source: McpErrorEvent[\"source\"] = \"system\",\n    severity: McpErrorEvent[\"severity\"] = \"error\"\n  ) {\n    this.emitEvent({\n      type: \"ERROR\",\n      error,\n      context,\n      source,\n      severity,\n    } as Omit<McpErrorEvent, \"timestamp\" | \"sessionId\" | \"requestId\">);\n  }\n\n  end(\n    chunk?: unknown,\n    encoding?: BufferEncoding | (() => void),\n    cb?: () => void\n  ): this {\n    let finalChunk = chunk;\n    let finalEncoding = encoding;\n    let finalCallback = cb;\n\n    if (typeof chunk === \"function\") {\n      finalCallback = chunk as () => void;\n      finalChunk = undefined;\n      finalEncoding = undefined;\n    } else if (typeof encoding === \"function\") {\n      finalCallback = encoding as () => void;\n      finalEncoding = undefined;\n    }\n\n    return super.end(\n      finalChunk as string | Buffer,\n      finalEncoding as BufferEncoding,\n      finalCallback\n    );\n  }\n}\n","export type McpEventType =\n  | \"SESSION_STARTED\" // When a new client session begins (either HTTP or SSE)\n  | \"SESSION_ENDED\" // When a client session ends (SSE disconnection)\n  | \"REQUEST_RECEIVED\" // When a request is received from the client\n  | \"REQUEST_COMPLETED\" // When a request completes\n  | \"ERROR\"; // When an error occurs during any operation\n\nexport interface McpEventBase {\n  type: McpEventType;\n  timestamp: number;\n  sessionId?: string;\n  requestId?: string; // To track individual requests within a session\n}\n\nexport interface McpSessionEvent extends McpEventBase {\n  type: \"SESSION_STARTED\" | \"SESSION_ENDED\";\n  transport: \"SSE\" | \"HTTP\";\n  clientInfo?: {\n    userAgent?: string;\n    ip?: string;\n  };\n}\n\nexport interface McpRequestEvent extends McpEventBase {\n  type: \"REQUEST_RECEIVED\" | \"REQUEST_COMPLETED\";\n  method: string;\n  parameters?: unknown;\n  result?: unknown;\n  duration?: number; // For REQUEST_COMPLETED events\n  status: \"success\" | \"error\";\n}\n\nexport interface McpErrorEvent extends McpEventBase {\n  type: \"ERROR\";\n  error: Error | string;\n  context?: string;\n  source: \"request\" | \"session\" | \"system\";\n  severity: \"warning\" | \"error\" | \"fatal\";\n}\n\nexport type McpEvent = McpSessionEvent | McpRequestEvent | McpErrorEvent;\n\nexport function createEvent<T extends McpEvent>(\n  event: Omit<T, \"timestamp\">\n): T {\n  return {\n    ...event,\n    timestamp: Date.now(),\n  } as T;\n}\n","import { AuthInfo } from \"@modelcontextprotocol/sdk/server/auth/types.js\";\nimport { AsyncLocalStorage } from \"node:async_hooks\";\n\nconst authContext = new AsyncLocalStorage<AuthInfo>();\n\nexport function getAuthContext(): AuthInfo | undefined {\n  return authContext.getStore();\n}\n\nexport function withAuthContext<T>(authInfo: AuthInfo, callback: () => T): T {\n  return authContext.run(authInfo, callback);\n}\n","import { EventEmitter } from 'node:events';\nimport type { ServerResponse } from 'node:http';\n\ntype WriteheadArgs = {\n  statusCode: number;\n  headers?: Record<string, string>;\n};\n\n// biome-ignore lint/suspicious/noExplicitAny: Not deterministic\nexport type BodyType = string | Buffer | Record<string, any> | null;\n\ntype EventListener = (...args: unknown[]) => void;\n\n/**\n * Anthropic's MCP API requires a server response object. This function\n * creates a fake server response object that can be used to pass to the MCP API.\n */\nexport function createServerResponseAdapter(\n  signal: AbortSignal,\n  fn: (re: ServerResponse) => Promise<void> | void\n): Promise<Response> {\n  let writeHeadResolver: (v: WriteheadArgs) => void;\n  const writeHeadPromise = new Promise<WriteheadArgs>(resolve => {\n    writeHeadResolver = resolve;\n  });\n\n  return new Promise(resolve => {\n    let controller: ReadableStreamController<Uint8Array> | undefined;\n    let shouldClose = false;\n    let wroteHead = false;\n    let statusCode = 200;\n    let headers: Record<string, string> | undefined;\n\n    const writeHead = (code: number, headersArg?: Record<string, string>) => {\n      if (typeof headersArg === 'string') {\n        throw new Error('Status message of writeHead not supported');\n      }\n      statusCode = code;\n      headers = headersArg;\n      wroteHead = true;\n      writeHeadResolver({\n        statusCode,\n        headers,\n      });\n      return fakeServerResponse;\n    };\n\n    const bufferedData: Uint8Array[] = [];\n\n    const write = (\n      chunk: Buffer | string,\n      encoding?: BufferEncoding\n    ): boolean => {\n      if (encoding) {\n        throw new Error('Encoding not supported');\n      }\n      if (chunk instanceof Buffer) {\n        throw new Error('Buffer not supported');\n      }\n      if (!wroteHead) {\n        writeHead(statusCode, headers);\n      }\n      if (!controller) {\n        bufferedData.push(new TextEncoder().encode(chunk as string));\n        return true;\n      }\n      controller.enqueue(new TextEncoder().encode(chunk as string));\n      return true;\n    };\n\n    const eventEmitter = new EventEmitter();\n\n    const fakeServerResponse = {\n      writeHead,\n      write,\n      end: (data?: Buffer | string) => {\n        if (data) {\n          write(data);\n        }\n\n        if (!controller) {\n          shouldClose = true;\n          return fakeServerResponse;\n        }\n        try {\n          controller.close();\n        } catch {\n          /* May be closed on tcp layer */\n        }\n        return fakeServerResponse;\n      },\n      on: (event: string, listener: EventListener) => {\n        eventEmitter.on(event, listener);\n        return fakeServerResponse;\n      },\n      get statusCode() {\n        return statusCode;\n      },\n      set statusCode(code: number) {\n        statusCode = code;\n\n        // If the status code is set after writeHead, we need to call\n        // writeHead again to update the status code.\n        if (wroteHead) {\n          writeHeadResolver({\n            statusCode,\n            headers,\n          });\n        }\n      },\n    };\n\n    signal.addEventListener('abort', () => {\n      eventEmitter.emit('close');\n    });\n\n    void fn(fakeServerResponse as ServerResponse);\n\n    void (async () => {\n      const head = await writeHeadPromise;\n\n      const response = new Response(\n        new ReadableStream({\n          start(c) {\n            controller = c;\n            for (const chunk of bufferedData) {\n              controller.enqueue(chunk);\n            }\n            if (shouldClose) {\n              controller.close();\n            }\n          },\n        }),\n        {\n          status: head.statusCode,\n          headers: head.headers,\n        }\n      );\n\n      resolve(response);\n    })();\n  });\n}\n","import { type Config, initializeMcpApiHandler } from \"./mcp-api-handler\";\nimport { createServerResponseAdapter } from \"./server-response-adapter\";\nimport type { ServerOptions as McpServerOptions } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport type { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\n\n/**\n * Creates a MCP handler that can be used to handle MCP requests.\n * @param initializeServer - A function that initializes the MCP server. Use this to access the server instance and register tools, prompts, and resources.\n * @param serverOptions - Options for the MCP server.\n * @param config - Configuration for the MCP handler.\n * @returns A function that can be used to handle MCP requests.\n */\n\nexport type ServerOptions = McpServerOptions & {\n  serverInfo?: {\n    name: string;\n    version: string;\n  };\n};\n\nexport default function createMcpRouteHandler(\n  initializeServer:\n    | ((server: McpServer) => Promise<void>)\n    | ((server: McpServer) => void),\n  serverOptions?: ServerOptions,\n  config?: Config\n): (request: Request) => Promise<Response> {\n  const mcpHandler = initializeMcpApiHandler(\n    initializeServer,\n    serverOptions,\n    config\n  );\n  return (request: Request) => {\n    return createServerResponseAdapter(request.signal, (res) => {\n      mcpHandler(request, res);\n    });\n  };\n}\n"]}